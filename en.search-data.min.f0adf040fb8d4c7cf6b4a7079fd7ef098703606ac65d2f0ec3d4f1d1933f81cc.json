[{"id":0,"href":"/note/docs/linux/","title":"Linux","section":"Docs","content":"Introduction #  Linux 相关的学习笔记\n"},{"id":1,"href":"/note/docs/golang/","title":"Go语言笔记","section":"Docs","content":"Introduction #  Golang 相关的学习笔记\n"},{"id":2,"href":"/note/docs/database/","title":"数据库相关","section":"Docs","content":"Introduction #  "},{"id":3,"href":"/note/docs/nginx/","title":"Nginx","section":"Docs","content":"Introduction #  "},{"id":4,"href":"/note/docs/etcd/","title":"Etcd","section":"Docs","content":"Introduction #  Etcd 相关的学习笔记\n"},{"id":5,"href":"/note/docs/queue/","title":"消息队列","section":"Docs","content":"Introduction #  消息队列相关的学习笔记\n"},{"id":6,"href":"/note/docs/elasticsearch/","title":"Elasticsearch","section":"Docs","content":"Introduction #  "},{"id":7,"href":"/note/docs/kubernetes/","title":"Kubernetes","section":"Docs","content":"Introduction #  Kubernetes 相关的学习笔记\n"},{"id":8,"href":"/note/docs/algorithm/","title":"算法知识","section":"Docs","content":"Introduction #  "},{"id":9,"href":"/note/docs/interview/","title":"面试相关笔记","section":"Docs","content":"Introduction #  "},{"id":10,"href":"/note/docs/material/","title":"学习资料","section":"Docs","content":"Introduction #  "},{"id":11,"href":"/note/docs/other/","title":"其他笔记","section":"Docs","content":"Introduction #  "},{"id":12,"href":"/note/docs/fund/","title":"基金数据","section":"Docs","content":"Introduction #  "},{"id":13,"href":"/note/docs/scheme/","title":"项目实践","section":"Docs","content":"Introduction #  "},{"id":14,"href":"/note/docs/geomancy/","title":"风水知识","section":"Docs","content":"Introduction #  "},{"id":15,"href":"/note/docs/life/","title":"生活日志","section":"Docs","content":"Introduction #  "},{"id":16,"href":"/note/docs/scheme/werewolf/","title":"狼人对决项目方案","section":"项目实践","content":" 狼人对决微信小程序实践项目方案书\n 功能模块图谱 #   小程序流程 #  授权登录 #   code rawData signature  拉取首页数据 #   uid 昵称 头像 性别 金币 等级 VIP 是否开启进阶房 "},{"id":17,"href":"/note/docs/geomancy/basics/","title":"风水入门知识","section":"风水知识","content":" 风水从古至今已延续千年，无论是房屋风水、办公室风水和阴宅风水，对我们的运势都有一定的影响。 好的风水不仅是在心理上给我们带来好的安慰，还能够在现实生活中真实的体会到风水的作用。\n 什么是风水 #   风水，本为相地之术，即临场校察地理的方法，也叫地相、古称堪舆术，相传风水的创始人是九天玄女，比较完善的风水学问起源于战国时代。 风水的核心思想是人与大自然的和谐，早期的风水主要关乎宫殿、住宅、村落、墓地的选址、座向、建设等方法及原则，原意是选择合适的地方的一门学问。 是中国历史悠久的一门玄术。也称青鸟、青囊，较为学术性的说法叫做堪舆。就是研究人类赖以生存发展的微观物质（空气、水和土）和宏观环境（天地）的学说。 天师后裔、风水大师张金华说：易经风水，空间于风水、时间于八字。\n 无极生太极 #   中国古代风水，起源于地球.太阳.月球三者关系。这是看得见，感受得到的。无极是怎样变到太极的？ 世人都是猜测，谁也说不清。宇宙的形成之后，中国古人取地球作为研究风水的太极点，太极从此而生。 即用太极抽象代表世间的万事万物，其大无外，其小无内。\n 太极生两仪 #   两仪即是阴（-）阳（+）。以地球作为太极点，地球固定的磁场方向（NS）从南到北极，或者说人们特定最南和最北端为地球南极和北极（NS），用阴（-）和阳（+）表示。 古人用一整套最客观.最直接的阴阳理论，作为看风水好坏的依据。\n 阴阳形峦风水（又称形法风水） #   以阴阳理论来研究风水，主要取其形，称为阴阳形峦风水。它出自于阴阳，风水研究本来就是专论阴阳，它来源直接.基因变异小，不需借助任何工具，开口直断，准确率高。 所以，看风水第一要事就是用阴阳理论考察，就是要符合阴阳道理。绝对不能违背阴阳。风水师为人断风水准确率低，或为人做风水不太灵验的原因，往往只用理气风水所致。\n 两仪生四象 #   有两种说法，一是地球磁场（阴阳）加上地球绕太阳旋转和本身自转，黑（-）白（+）阴阳交替，阴阳两仪各分别叠加阴阳产生四象。 二是地球绕太阳转一周（一年）产生春夏秋冬四季现象。两种说法都是地球和太阳作用的结果，是一致的。\n 四象生八卦 #   太阳直射在地球南北回归线上一个来回为一年。地球周而复始不停运动，年复年，日复日，阴阳交替。 即是在四象基础上，再加阴阳（4象x阴.阳2=8）成八卦，乾兑离震巽坎艮坤。也是八个方位。\n 六十四卦 #   地球有规律绕太阳不停旋转，生成八个基础卦，再互为相荡八次（8x8=64）即成64卦。 以64卦为基础派生出《周易》.《梅花易数》.《六爻预测》三个预测学和《三元玄空大卦》.《周易八卦风水》两个理气风水学。\n 先天八卦 #   在八卦八个方位上配上天地.水火.雷风.山泽自然现象而成先天八卦，代表地球的自然现象，为八卦之体。\n 河洛与后天八卦 #   八卦配上洛书数，成为后天八卦，载九（离）履一（坎），左三（震）右七（兑），二（坤）四（巽）为肩，六（乾）八（艮）为足。 后天八卦为用。再有河图1.6，2.7，3.8，4.9之说。以上便是无极生太极，太极生两仪，两仪生四象，四象生八卦，八卦定乾坤的全过程。\n 五行起源 #   五行不是金木水火土五种物质，而是太阳光照射地球，在地球上表现出春夏秋冬四种形态（4季+1地球=5行）称五行。 春天万物生发象木，夏天炎热象火，秋天万物萧杀象金，冬天寒冷象水。四季变换不是突然而至，而是有个缓冲过程，缓冲区为四季土。\n 五行旺衰 #   各个季节中五行的旺.相.休.囚.死状态。\n 五行相生相克 #   相生相克维持大自然秩序和平衡。\n 十天干 #   五行中各分阴阳（5行x阴阳2=10天干）。甲为阳乙为阴，丙为阳丁为阴，戊为阳己为阴，庚为阳辛为阴，壬为阳癸为阴。\n 十二地支 #   春夏秋冬四季，每季三个月（4x3=12），或地球绕太阳一周，月球绕地球转12圈，记作12个月。 用子丑寅卯辰巳午未申酉戌亥代表。十二地支派生出以下内容： \u0026lt;\\br\u0026gt; （1），十二长生：十天干寄十二宫。 \u0026lt;\\br\u0026gt; （2），大六壬学：太阳过宫称月将，月将加时，起四课三传的运算课式断事。可预测也可作日课用。 \u0026lt;\\br\u0026gt; （3），神煞：十二地支的先后次序关系成神煞。 \u0026lt;\\br\u0026gt; （4），十二地支刑.冲.化.合.害与三合风水学：十二地支有温度.时间.方位之分，形成各种关系。四大水口：乙丙交而趋戌，辛壬会而聚辰，丁庚纳斗牛气，金羊收癸甲之灵。此是地理五诀三合风水的立论。 \u0026lt;\\br\u0026gt; （5），罗盘（经）二十四山：每年十二个月，每月两个节气（12X2=24）共二十四节气，对应二十四方位，即是二十四山。 配上磁针，刻上各家风水的内容，就成为罗盘。罗盘虽是二十四方位，实质也是地球绕太阳一周的记录，反映的是一年的气候变化过程。周而复始，与地球绕太阳转同步。 完全没有神秘的地方。这里要指出的是，所有罗盘的二十四山中，寅午戌申子辰乾坤甲乙壬癸十二字都是红色的；亥卯未巳酉丑艮巽丙辛庚丁黑色字。\n 六十甲子 #   十天干十二地支组合的最小公倍数=60，为六十甲子。其派生：\u0026lt;\\br\u0026gt; （1）六甲空亡。 \u0026lt;\\br\u0026gt; （2）纳音。\u0026lt;\\br\u0026gt; （3）三元九运玄空飞星.奇门遁甲学：六十甲子配上.中.下三元，称上元中元下元三元甲子(3x60=180年)。\u0026lt;\\br\u0026gt; 180为大元，每二十年为一运，共九运，统称三元九运。利用1至9数配上洛书九宫，阳顺飞.阴逆飞，为玄空飞星学。 配十天干，九星，八门，八神，产生奇门1080局。为奇门遁甲术。外加十二建星和十二月将作为预测吉凶。 这两门学术最显著的特点就是旺衰吉凶随时间的改变而改变。现代人利用它的理论来调整空间，摆放风水物，改门向达到趋吉避凶。\u0026lt;\\br\u0026gt; （4）四柱日课.算命.合婚：六十甲子作为记时用具，用来纪年.纪月.纪日.纪时称为四柱。用作择吉的称日课。四柱配十神为八字算命。男女双方八字论合婚。\n  理气法 #   论断阳宅，以建筑里面的格局、陈列、摆饰为基准，对人的影响。论断阴宅，则以墓碑为主、墓穴为辅，用来论断阳间后代之吉凶。 理气法以《八宅明镜》及《阳宅三要》为主轴。根据阴阳、五行之[生、克、制、化]，及八卦、九宫、十天干、十二地支的演生变化，来断吉凶。\n 峦头法 #   论断建筑物外面的大环境，对人的影响。以龙、穴、砂、水的形、势，互动来定吉凶。\n 龙指的是什么 #   就是山脉、细分太祖山、少祖山、父母山，亦称少阳山。风水中，将山势的起、伏、绵延、变化，用中国人最崇拜的龙来形容，并赋予生命。\n 穴指的是什么 #   就是建物。含阴宅、墓穴与阳宅、房、舍观看山脉走向、起伏、推断[气]所凝聚胎息的位置，就是穴位。 如同人身经络上的气节点——穴位。阴宅论法即为墓穴。阳宅而论，小则为宅、院，中者为市、镇，大则可为国家、重点取决于龙脉的大小。\n 砂指的是什么 #   指的是穴前后左右的四兽山、丘。即俗称的左青龙、右白虎、后玄武、前朱雀。炫舞指的是后方略高的小山，做为靠山;朱雀指的是前方的小丘，是为朝山、亦名案山。\n 水指的是什么 #   指的是河川、水池及道路。河川的水质及流速，会直接影响当地人的个性： 水质清澈——流速绵延缓慢，居民性格温文，话语轻柔。 水质浑浊——居民人品必差。 水流湍急——居民个性也会急躁、豪迈。 水流浮、浅——居民大都朝三暮四、心浮气躁。 河川遇雨湍急，无雨则干涸——当地必有盗匪，黑道猖獗，百姓生活穷困。\n 五行生克 #   金.水.木.火.土（初学者按此顺序背诵，顺次相生，隔位相克) \u0026lt;\\br\u0026gt; 金生水.水生木.木生火.火生土.土生金\u0026lt;\\br\u0026gt; 金克木.水克火.木克土.火克金.土克水\n 天干 #   1：甲.乙.丙.丁.戊.己.庚.辛.壬.癸（按顺序背诵）\u0026lt;\\br\u0026gt; 2：其中阳干为：甲.丙.戊.庚.壬. 阴干为：乙.丁.己.辛.癸 3：天干的五行方位：.甲乙东方木.丙丁南方火.戊己中央土.庚辛西方金.壬癸北方水\n4:天干的合化：甲己合化土.乙庚合化金.丙辛合化水.丁壬合化木.戊癸合化火\n5:天干掌图：\n 木的特性 #   木曰：“曲直”。曲者，屈也；直者，伸也。故，木有能屈能伸之性。木纳水土之气，可生长发育。故木又具有生发、向上、修长、柔和、仁慈之性。木主仁。\n 火的特性 #   火曰“炎上”。炎者，热也；上者，向上也。故火有发热、温暖、向上之性。火具有驱寒、除湿、煅炼金属之能。火生于木，其势急，其性烈，其情恭。火主礼。\n 土的特性 #   土曰“稼穑”。播种为稼，收获为穑，土具有载物、生化、藏纳之能，故土载四行，为万物之母，具贡献、厚重之性。土主信。\n 金的特性 #   金曰“从革”。从者，顺从，服从也；革者，变革，改革也。改革、变革必施以威力，故金具有能柔能刚、延展、变革、肃杀的特性。金主义。\n 水的特性 #   水日“润下”。润者，湿润也；下者，向下也。故水具有滋润、向下、淹藏的特性。水主智。\n 河图 #   口诀：\u0026lt;\\br\u0026gt; 一六共宗，为水居北 \u0026lt;\\br\u0026gt; 二七同道，为火居南 \u0026lt;\\br\u0026gt; 三八为朋，为木居东 \u0026lt;\\br\u0026gt; 四九为友，为金居西 \u0026lt;\\br\u0026gt; 五十同途，为土居中 \u0026lt;\\br\u0026gt; 具体些就是: \u0026lt;\\br\u0026gt; 一六这两个数字的河图五行属水 \u0026lt;\\br\u0026gt; 二七这两个数字的河图五行属火 \u0026lt;\\br\u0026gt; 三八这两个数字的河图五行属木 \u0026lt;\\br\u0026gt; 四九这两个数字的河图五行属金 \u0026lt;\\br\u0026gt; 五十这两个数字的河图五行属土 \u0026lt;\\br\u0026gt; 不过河图为体，洛书为用，河图数字五行一般情况下仅用在不变的环境，比如楼层，房屋间数等。\n 洛书 #   神话传说，古时洛水出现龟背上载有图形的神龟。大禹治水依据“洛书”，制定“九畴”来治理天下。 洛书图，是远古时代的方位图，由河图变化而来，数字一至九代表九宫、九星。 九个数字，九在正南，对应离卦，象征龟头，一在正北对应坎卦，象征龟尾，龟身的左侧和右侧为三和七，龟的二前腿为二和四，龟的二后腿为六和八，五在中央。 洛书的八卦为后天八卦，离坎取乾坤为天地之用，火上升，水下降。 从自然的角度来理解，阳气上升，阴气下降。活火在地下为暖，雷为震则动，坎在地上聚焦、蒸发，离太阳普照。巽风、艮山上接于天下接于地，把天和自然现象连接在一起。 故东南方多湖泽，不断蒸发，又多风，湖泽源头来于西方，水由西南向东流，西南、西北为尊位，居乾坤。 乾天纯阳将地的阴气全摄取，故天上寒冷，坤地纯阴，将天的阳气全收取，故地心纯热，成天地交泰，化生万物。 洛书的奇数五在中央，北一、东三、西七、南九，偶数分占四角。由东北起八、三、四、九与河图横列的数相同，二、七、六、一与河图纵列的数相同。 相对两数的和都等于十数，与河图吻合。故洛书的相对合十，是大玄空旺财理论之根据。 河图；它所表示的数据是：一六居北方，为水；二七居南方，为火;三八居东方，为木;四九居西方，为金；五十居中央，为土; 河图口诀：一六同宫，二七同道，三八为朋，四九为友，五十同途。洛书；它所表示的数据是:戴九履一，左三右七，二四为肩，六八为足，五居中央。 从洛书的数据来分析，它是由河图演化而来的，如果说，河图是宇宙结构的缩影，那么，洛书则是地球物貌的缩影。\n 二十四山与卦位以及方向的相对关系 #   具体解释： 1：乾卦统领戌乾亥三山，位置在西北，坐亥向巳坐乾向巽坐戌向辰的房子统称乾宅 2：坎卦统领壬子癸三山，位置在正北，坐壬向丙坐子向午坐癸向丁的房子统称坎宅 3：艮卦统领丑艮寅三山，位置在东北，坐丑向未坐艮向坤坐寅向申的房子统称艮宅 4：震卦统领甲卯乙三山，位置在正东，坐甲向庚坐卯向酉坐乙向辛的房子统称震宅 5：巽卦统领辰巽巳三山，位置在东南，坐辰向戌坐巽向乾坐巳向亥的房子统称巽宅 6：离卦统领丙午丁三山，位置在正南，坐丙向壬坐午向子坐丁向癸的房子统称离宅 7：坤卦统领未坤申三山，位置在西南，坐未向丑坐坤向艮坐申向寅的房子统称坤宅 8：兑卦统领庚酉辛三山，位置在正西，坐庚向甲坐酉向卯坐心向乙的房子统称兑宅 先天八卦相传关于八卦为伏羲所画。 #   先天八卦来自于河图，它是竖立着向南看的，是天南地北为序，上为天为乾，下为地为坤，左为南为离，右为北为坎。\n 后天八卦 #   后天八卦为文王所画。它来自于洛书。后天八卦是平放于地面由北向南看的，上离下坎，左震右兑。\n 洛书九宫方位图 #   用洛书配后天八卦图，是目前应用最广泛的图式。4巽9离2坤3震5中宫7兑8艮1坎6乾用洛书配先天八卦的下图： 4兑9乾2巽3离5中宫7坎8震1坤6艮九宫数与八卦一白坎；北方水.壬子癸三山。 二黑坤；西南土.未坤申三山。 三碧震；东方木.甲卯乙三山。 四绿翼；东南木.辰巽巳三山。 五黄中宫；中央.戊已土。 六白乾；西北金.戌乾亥三山。 七赤兑；西方金.庚酉辛三山。 八白艮；东北土.丑艮寅三山。 九紫离；南方火.丙午丁三山。 六、二十四山:二十四山内含：八干，四维，十二地支。八干:甲.乙.丙.丁，庚.辛.壬.癸。（因戊已土居中央，二十四山十天干中只剩下八干）。 四维:乾.坤.艮.巽（二十四山不含坎震离兑）。十二地支:子.丑.寅.卯.辰.巳.午.末.申.酉.戌.亥。 七、二十八星宿：是黄道赤道天区：1.东方苍龙七宿:角亢氏房心尾箕。2.南方朱雀七宿:井鬼柳星张翼轸。3.西方白虎七宿:奎娄胃昂毕嘴参。4.北方玄武七宿:斗牛女虚危室壁 内容包括： 阴阳五行、五行相生、五行相克、五行河洛数、十干阴阳、地支阴阳、八卦阴阳、先后天八卦、二十四山及阴阳 一、阴阳五行:金、木、水、火、土。 二、五行相生;金生水、水生木、木生火、火生土、土生金。 三、五行相克:金克木、木克土、土克水、水克火、火克金。 四、五行数据:一水、二火、三木、四金、五土。此为先天五行数，它来自于河图。 十干阴阳 甲乙属木，甲为阳，乙为阴，位居东方。 丙丁属火，丙为阳，丁为阴，位居南方 戊已属土，戊为阳，已为阴，位居中央 庚辛属金，庚为阳，辛为阴，位居西方。 壬癸属水，壬为阳，癸为阴，位居北方 地支阴阳 子、寅、辰、午、申、戌为阳。 丑、卯、巳、未、酉、亥为阴。 1:子丑寅卯辰巳午未申酉戌亥（按顺序背诵，以后许多推算会用到） 2:第二种顺序：子午卯酉辰戌丑未寅申巳亥这种顺序直接可以记住地支六冲，以后许多推算也会用到这种顺序 3:第三种顺序（三合局）：申子辰三合水局亥卯未三合木局寅午戌三合火局巳酉丑三合金局 4:第四种顺序（三会局）：寅卯辰会东方木巳午未会南方火申酉戌会西方金亥子丑会北方水 以上这几种顺序都要牢记，以后会经常用到。 5:地支六冲：子午冲卯酉冲辰戌冲丑未冲寅申冲巳亥冲 6：地支属相配：子鼠丑牛寅虎卯兔辰龙巳蛇午马未羊申猴酉鸡戌狗亥猪 7：地支的五行：寅卯木巳午火申酉金亥子水辰戌丑未土 8：地支代表月份：正月寅二月卯三月辰四月巳五月午六月未七月申八月酉九月戌十月亥十一月子十二月丑 八卦阴阳 乾、坎、艮、震为阳 巽、离、坤、兑为阴 八卦 先天八卦数： 乾一.兑二.离三.震四.翼五.坎六.艮七.坤八。 后天八卦数： 坎一.坤二.震三.巽四.乾六.兑七.艮八.离九。 九、二十四山及阴阳：二十四山由四维、八干、十二地支组成，罗盘上分别从坎山壬子癸、艮山丑艮寅、震山甲卯乙、巽山辰巽已、离山丙午丁、坤山未坤申、兑山庚酉辛、乾山戍乾亥。如下罗盘图 根据阴阳不同可分为三元龙：天元龙、人元龙、地元龙。 地元龙：阳——甲、庚、壬、丙，阴——辰、戌、丑、未 天元龙：阳——乾、坤、艮、巽，阴子、午、卯、酉 人元龙：阳——寅、申、已、亥，阴：癸、丁、乙、辛 风水学入门图解重点名词有哪些 明堂 又名“内阳”。堪舆家称穴前平坦开阔、水聚交流的地方。按距离穴场的近远，又可分为小明堂、中明堂〈内明堂〉、大明堂〈外明堂〉。廖瑀《泄天机明堂入式歌》：明堂气聚始为奇，不聚即非宜。凡是穴前坦夷处，便是明堂位。....明堂光明照万方，宽阔始为良。”缪希《葬经翼;明堂篇》：“明堂者，穴前水聚处也。”徐善继《人子须知;水法》：“明堂欲其平正开畅，团聚朝抱。”又同书〈穴法〉：“若明堂不正不聚，倾泻倒侧，则是真气不融，纵有美穴，亦须弃置。” 峦头 是风水两大流派之一，“江西派”所重之的学理“峦体”。峦体以龙砂穴水为四大网，主要应用于占测墓葬，其次是选择阳基。清朝丁芮朴《风水袪惑》：“风水之术，大抵不出形势、方位两家。言形势者，今谓之峦体，言方位者，今谓之理气。唐宋诗人，各有宗派授受。”《四库全书总目;葬书提要》引明朝王袆《青岩丛录》：“择地以葬，其术本于?郭璞，....后世之为其术者分为二宗....曰江西之法，?于人杨筠松，曾文辿及赖大有、谢子逸辈，尤精其学。其为说主形势，原其所起，即其所止，以定位向，专指龙穴砂水之相配，其它拘泥在所不论。今大江以南无不尊之者。” 理气 是“闽派”所重之学理。与峦体之法并为堪舆术两大流派。开宗于福建，以秦汉“五姓图宅”五行生克论吉凶为权舆，至南未盛行于世。其法专主阴阳配合生剜制化，以罗盘定空间方位阴阳，并取八卦五行，飞星翻布定生剜吉凶，亦即通过年运与宅、墓的坐向推算主人命运的时空因素，占测最佳选择。理气之法依据《周易》的原理以八卦，十二支，天星，五行为四大网，比峦体专论山川形势更为抽象。明清以后，术家倾向“峦头为体，理气为用”，两派渐渐合流。但在实际应用，理气之法侧重于营宅方面。 藏风 堪舆家称穴场四周形局紧密，能卫护穴庭，使不受外风侵袭而耗散“生气”。郭璞《葬书》：“风水之法，得水为上，藏风次之。” 聚水 指穴山前水聚成沼。堪舆家谓主生气厚蓄，为吉贵之象。徐善继《人子须知水法》：“穴前水最宜深聚，盖水本动，妙在静中，聚则静矣，此其所以为贵。”缪希雍《葬经翼难解二十四篇》：“《经》云‘朱雀....泽于将衰’者，言将出必先汇泽，则有蓄聚也。” 龙 风水学中“龙”者，山?也。因山?逶迤起伏如龙形，故称。廖瑀《泄天机寻龙入式歌》：“爰从重浊凝于于地，便有高低势。势来起伏是行?，前贤呼作‘龙’。”蔡元定《发微论》：“夫山以静为常，是唯无动，动则成动矣。成龙之山，必踊跃翔舞，若其偃硬?勒，则不融结者也。” 砂 又名“砂头”。堪舆家对龙穴前后左右诸山的总称。古时以砂子堆拨成传授寻龙点穴之法，故称。徐善继《人子须知;砂法》：“夫砂者，穴之前后左右山也。....前朝、后乐、左龙、右虎、罗城、侍卫、水口诸山，与夫官、鬼、禽、曜，皆谓之砂。”廖瑀《泄天机;消砂入式歌》：“真龙落处四山聚，亦自有名义。昔贤何以唤为‘砂’？于理自呼差。杨、曾教人原有格，五、九只从砂上拨，因兹名作《拨砂经》。” 砂随位置、形状而有各种称呼；宋．张子微着的《玉髓真经》、明．徐善继、徐善述着的《人子须知》、徐试可着的《天机会元》（顾陵冈原着）等书内有很多图形可以参考。在穴前，近者为“案”，远者为“朝”；在穴后，为“鬼星”、“乐山”；在穴左，为“龙”；在穴右为“虎”；龙、虎上又生砂，明见者为“官星”（多在穴前），不见者为“曜星”：在穴后行龙身上者为“护”、“从”；在水口旁边及内外者为“捍门”、“华表”、“罗城”、“北辰星”、“罗星”（禽星、落河火星），在穴旁外缠山或穴后左右者为“插耳”（太乙、天乙）。 穴 即“龙穴”。堪舆家所认为的土中气?聚结处。或成洼状，或成突状。谓“穴”生气最旺，适合安坟立宅。缪希雍《葬经翼;察形篇》：“穴者，山水相，交阴阳融凝，情之所钟处也。”同书《怪穴篇》：“穴以藏聚为主。盖藏聚则精气翕集，暖而无风，暖则无水，无风则无蚁，三害不侵，则穴得矣。”徐善继《人子须知》卷首：“穴者，盖犹人身之穴位，取义至精。” 水 别称“外气”。与“龙”“砂”“穴”并为相地术的四大内容。堪舆家认为，水为气之母，?气靠水运送而行，而水拦截而止，寻龙点穴，要根据水流的有无、大小、方向、形态等作出判断和印证。水势以深聚缓和为吉，以激湍冲割为凶。郭朴《葬书》：“风水之法，得水为上，藏风次之。”“《经》曰：‘外气所以聚内气，过水所以止来龙。’”蔡元定《发微论》：“两水之中必有山，故水会即龙尽，水交则龙止，水飞走则生气尽，水融注则内气聚。”徐善继《人子须知;水法》：“水深处民多富，水浅处民多贫，水聚处民多稠，水散处民多离。”“水送则龙行，水界则龙止”，这个观念在没有明显高低落差的平原（平阳、平洋）地区，用于寻龙点穴是很重要的。有经验的地师可以从水路的来源、转折、出口、停潴……等，迅速点出穴位，而且知道龙（陆块）从何处发?、如何顿趺起伏及分枝、该立何向（使龙神卦气清纯不杂）？结什?样的地局（富贵、贫*、寿天、格局大小……）？ 向 堪语术语。指宅或墓的坐向，与龙、砂、穴、水并为相地术五大要项。术家认为，坐向大要以背山面水，坐北朝南，避凶迎吉为佳，定向既要视察地形，也要罗盘占测，而以地形坐向为先?条件。反映在运盘上，山与向的运星不管是山到向，还是上山下水，其吉凶均须依实际地形裁夺，如到山到向虽吉，而坐山无山，向首无水，或坐山有水，向首有山，仍不宜选用。 由于自然山水往往不免?差人意，术家每采取变通办法来解?问题。如偏字之说，定山向以山为准，依水而变，用地盘测量，山龙若从子方来，午方有水，即用子山午向，是为最理想的风水宝地。但如水不在午方而在丙方，则改用壬山丙向以止气，余类推。 清朝钱泳《履园丛话;营造》：“凡造屋必先看方向之利不利，择吉即定，然后运土平基。”清赵廷栋《地理五诀》卷一：“一曰龙，龙要真；二曰穴，穴要的；三曰砂，砂要秀；四曰水，水要抱；五曰向，向要吉。”旧题南唐何溥《灵城精义》卷下：“龙以?为主，穴以向为尊，水以向而定，向以局而分。”《注》：“此以水与穴皆以向为重。凡论气者不可不论向也。凡葬法内之乘气，一以?为主，亦以正五行为主，别无他门。若坐穴立向，则虽内以首，水自寅艮来，由戌干去，若以双山五行属木，则冲破胎养，以正行属水，则冲破冠带，俱不合度，当立丙丁向，则水可消。盖以玄空五行论，则丙丁属火，其穴在戌，用可收艮之水而发福。此以玄空五行收向上之水也。水有息道漏道，从入而成，至山向而折之，乃漏道，则生成之局非人为也。故古人定向在于收局，当用双山定之，如卯龙巽庚，水朝金局也，出艮方则金气己成，当立庚向，盖从煞正为迎神通煞之法。....昔人云：无绝水有绝向。盖山水已结，未有不可用者，或水有不合，当于向上转移而消之。自古立向消水有许多法度，非以滋后人之惑，只是今人有个法度，以合山川之性情，不至拂逆而有败地耳。” 祖山 风水家把发的山称为“祖”，有经验的人可从河流的起源来寻找，也可从地图的标高来判断（明朝爱国将领袁崇焕的祖坟，本人就是在一次看地图时偶然发现，原来就在自己居住地附近）。杨筠松是用“望气法”来看，《撼龙经》说：“寻龙望气先寻?，云雾多生是龙脊，春夏之交与二分，夜向云霓生处觅；云霓先生绝高顶，此是龙楼宝殿定，大脊微微云自生，雾气如多反难证。先寻雾气识正龙，?望枝龙观远应，因就正龙行?处，认取破禄中间行……”。丘延翰的《天机素书》内也记载这种“望气法”。古代的交通不便利，要寻找祖山，必须花费很久的时间，经历险境，现代则轻而易举，从卫星照片、空测图及各种地图，就可迅速查得。通常说的祖山包括： 1）太祖山：龙之初发?，是一个大区域（全世界．全国）的最高峰；如世界最高峰的喜马拉雅山，中国最高峰的昆仑山，日本的富士山，台湾的玉山……都是太祖山。其山高大，石骨鳞峋，为群山之特拔者；远望耸秀，可爱，近觑巉岩，可畏。据镇一方，乃群龙之所从出，大则为邦国都郡，小则为县邑。山体端严方正，则一方所产之人，多贤能俊秀；偏斜低小，则一方所产之人，多愚蠢粗顽。 2）少祖山：是太祖山发?之后，再冲起的高山，又称为“应星”；其形状与太祖山不同，或尖、或圆、或方，精神充满，形象秀丽。风水家以此山定龙?的美恶。古语云：“辞楼下殿峰峦秀，预似前头异气钟。”“少”的意义是：接续“太”，如人伦的继志述事，克绍箕裘，有任重道远的负担。大祖为祖山，少祖为宗山。 3）列祖山：“列祖”是总举先人的称谓，少祖山发?之后再起高峰，三三两两、五五六六，这些中间相间的山峰都叫做列祖山。此山多属斜身旁落，开?分龙的山峰，在九星中，多是破军星、禄存星的形体。从列祖山可分辨龙?的行?。 父母山 结穴的主山叫父母山，又叫“玄武脑”、“盖山”、“照山”、“太阳山”。廖璃说：“若是山家结穴龙，定起主星峰。”此山以星举开面．?穿心者为上，旁出者次之。风水在在寻龙的历程中，是从太祖山分别龙的贵*，从少祖山分别龙的善恶，从列祖山分别龙的去向，从父母山分别龙的作用。一般人最喜坐后靠着山峰。但杨筠松的《都天宝照经》说：“家家坟宅后高悬，太阳不照太阴偏；必主其家多寂寞，男孤女寡实堪怜。”即指出山龙、平洋的不同，山龙以背靠端秀山峰为正局，挨星要“旺山旺向”之局。平洋大都后空，以坐空为正局。 中国风水的起源 殷商时期 到了殷周时期，已经开始了有文字记载的相地活动。如殷墟出土的甲骨文中就有大量的关于建筑的卜辞，如作邑、作案、作宗庙、作宫室、作塘等等。 秦汉：形成时期 而风水术的形成时期却是秦汉时期。在这个时期内，大规模的宫室营建为风水术的形成造成了物质前提。董仲舒的阴阳五行学说和孟喜、京房等人的易学理论为风水以及一切术数提供了理论与方法。特别是东汉神学思潮使得建筑中各种禁忌与迷信越发盛行，如“起宅盖房必择日”，“太岁头上不能动土”已成为阳宅建筑中应遵循的重要规则。 此时，阴宅风水理论也在渐渐形成。例如韩信年轻时，母亲死，家里穷，不能在村墓中葬母，就择高敞地葬母。后来他功成名就，封为楚王。秦末另有李仲翔祖葬城纪，他三次梦见有人告诉他，葬地的山形如川字，法当战死。仲翔不信，汉初果战于狄道而死。 与风水活动频繁的同时，秦汉时期还出现了一批有关风水的专著，如《堪舆金匮》、《宫宅地形》、《周公卜宅经》、《图宅术》、《大衍元基》、《葬历》等等。这表明，秦汉时期风水术已经完成了从实践到理论的形成过程，也可以称为风水学了。 隋唐：传播时期 隋唐时期，隋宰相杨恭仁准备仁祖辈的葬地，请了海内有名的相地家卜地，这些人各有一套，杨恭仁不知听谁的好。他就密派人回家乡取葬地四角的土各一斗，并在历书上写着地的形势。相地家们都没说准。有个叫舒绰的说：“此土五尺外有五谷，得其一即是福地，世为公侯。”杨恭仁请舒绰到其地察看，挖地七尺，果然发现一洞穴，贮藏七八斗粟，这里原是粟田，蚁啄而成穴。杨恭仁于是重赏了舒绰。 到了唐代，相地活动与风水术日益分化，风水术侧重于看坟地，迷信色彩十分严重。据《通典》卷138引《开元礼》记载，唐代不论是官人还是庶人，只要死了，都要择地择日下葬，这成为一种很普遍的习俗。唐代还设有司天监，监里的官员都懂风水术。 宋朝：兴盛时期 宋代真正到达风水术盛行的时代，宋徽宗就是一个很相信风水的皇帝。他原先没有儿子，有个叫刘混康的术士告诉他，京师西北隅地势过低，如培筑增高，当得多男之喜。徽宗就命令大兴土木，叠起冈阜，高约数仍，后来果然得了儿子。徽宗就更加相信风水术了，改筑延福宫，又命灵素择地，修建上清宝篆宫。 在宋朝，葬地的好坏，被认为与吉凶有关。宋人认为旧坟地不宜葬。钱希白《小说》记载宋初，钱文炳的妻子死了，炳从小精于相地术，就在报恩院侧的松林中选得一穴，有个僧人告诉他这里已有古圣贤葬于此，不可重新营葬。文炳不从，掘地发现数重石板，石中飞出一枚黑蜂对着文炳的右眉一螫，文炳头肿如斗，当晚身亡。 宋代真正到达风水术盛行的时代，宋徽宗就是一个很相信风水的皇帝。他原先没有儿子，有个叫刘混康的术士告诉他，京师西北隅地势过低，如培筑增高，当得多男之喜。徽宗就命令大兴土木，叠起冈阜，高约数仍，后来果然得了儿子。徽宗就更加相信风水术了，改筑延福宫，又命灵素择地，修建上清宝篆宫，劳民伤财，导致国库空虚、国力下降，政权衰败。 在宋朝，葬地的好坏，被认为与吉凶有关。宋人认为旧坟地不宜葬。钱希白《小说》记载宋初，钱文炳的妻子死了，炳从小精于相地术，就在报恩院侧的松林中选得一穴，有个僧人告诉他这里已有古圣贤葬于此，不可重新营葬。文炳不从，掘地发现数重石板，石中飞出一枚黑蜂对着文炳的右眉一螫，文炳头肿如斗，当晚身亡。 但风水宝地不是人人都可享受的，土地各有其主。《夷志坚》叙述陈魏公父墓说，福建莆田有一块富民的葬地，富民葬此处，子孙都病了。有个风水师说，这块地应当卖掉才会断除病根。后来，富民按风水师的意见卖了地，子孙的病就好了，而买地的一家不仅不病，还当上了宰相，风水师说这是地得其主。 明清：鼎盛时期 但到了明清时代，风水术进入鼎盛时期。明太祖朱元璋建都金陵(南京)，为都城的风水花了不少精力。金陵城外诸山，都面向城内，有朝拱之意。只是牛首山和太平门外的花山，背对城垣，独无拱卫之意，朱元璋为此怅然不乐。传说他命刑部带着刑具，将牛首山痛打一百棍，又于形象如牛首处凿石数孔，用铁索锁转，使之形势向内。又让人在花山肆行采樵，不让有翠微生色。 后来，明成祖还是把都城迁到北京。在营建北京的过程中，始终是按照风水观念进行的。如天坛圆丘西北有座坐西朝东的斋宫，其朝向很特别，与传统的坐北朝南不一样。这是因为，当时的人认为，皇帝到天坛祭天，苍天是父，皇帝是天子，儿子在父亲面前不能坐北朝南(居尊)，否则违背了礼制。甚至斋宫的瓦都不能用黄色，而应用绿琉璃瓦，以示区别。 清王朝对阳宅建筑也是很讲究的。如颐和园的排云殿就是风水极佳之处。排云殿的位置处于从佛香阁至“云辉玉宇”牌楼中轴线的中间，有神物保枯，稳居其中，取太平吉祥之意。殿中大厦上写着“蕃厘经纬”“永固鸿基”。殿名是根据风水术祖师郭璞的诗“神仙排云出，但见金银台”中的“排云”二字命名。排云殿傍山依水，背靠苍翠的万寿山，面朝碧绿的昆明湖。慈禧太后的六十、七十两次庆寿都在此地举行。 不仅帝王之家注重风水，民间也普遍讲究风水，以士人为重。《儒林外史》记载，范进的母亲死后，范进请阴阳先生写七单。当时的阴阳先生是专替丧家推算殓葬日辰，看风水，相地脉，替人家选择吉日的职业术士。七单是记载死者入硷时辰，触犯禁例和七七日期的单子。为“谢风水”，范进花了不少银子。阴阳先生说当年山向不利，只好把棺材搁在家里不葬。终日打听风水宝地，以图得到吉祥的后果。 "},{"id":18,"href":"/note/docs/fund/funds/","title":"基金数据分析","section":"基金数据","content":" 爬取天天基金网的规模超过10亿的被动型（指数型）股票基金的数据，并按规模由大到小排序\n 持有列表 #  |代码 | 基金名称 | 基金类型 | 成立日 | 基金规模 | 跟踪误差 | 详情 | | 501057 | 汇添富中证新能源汽车A | 指数型-股票 | 2018-05-23 | 60.58亿 | 0.17% | 详情 | | 160632 | 鹏华酒A | 指数型-股票 | 2015-04-29 | 51.75亿 | 0.17% | 详情 | | 000961 | 天弘沪深300ETF联接A | 指数型-股票 | 2015-01-20 | 30.32亿 | 0.07% | 详情 | | 004854 | 广发中证全指汽车指数A | 指数型-股票 | 2017-07-31 | 15.24亿 | 0.18% | 详情 |\n 基金列表： #     代码 基金名称 基金类型 成立日 基金规模 跟踪误差 详情     161725 招商中证白酒指数(LOF)A 指数型-股票 2015-05-27 658.45亿 0.16%  详情   510050 华夏上证50ETF 指数型-股票 2004-12-30 544.31亿 0.03%  详情   510300 华泰柏瑞沪深300ETF 指数型-股票 2012-05-04 483.65亿 0.02%  详情   510500 南方中证500ETF 指数型-股票 2013-02-06 391.77亿 0.02%  详情   512880 国泰中证全指证券公司ETF 指数型-股票 2016-07-26 320.49亿 0.03%  详情   510330 华夏沪深300ETF 指数型-股票 2012-12-25 289.48亿 0.02%  详情   512000 华宝券商ETF 指数型-股票 2016-08-30 238.49亿 0.03%  详情   510180 华安上证180ETF 指数型-股票 2006-04-13 235.43亿 0.03%  详情   110003 易方达上证50增强A 指数型-股票 2004-03-22 230.52亿 0.37%  详情   159919 嘉实沪深300ETF 指数型-股票 2012-05-07 227.95亿 0.02%  详情   515050 华夏中证5G通信主题ETF 指数型-股票 2019-09-17 171.16亿 0.02%  详情   159995 华夏国证半导体芯片ETF 指数型-股票 2020-01-20 162.53亿 0.03%  详情   510880 华泰柏瑞上证红利ETF 指数型-股票 2006-11-17 156.79亿 0.15%  详情   159915 易方达创业板ETF 指数型-股票 2011-09-20 149.24亿 0.02%  详情   160706 嘉实沪深300ETF联接A 指数型-股票 2005-08-29 131.93亿 0.07%  详情   512660 国泰中证军工ETF 指数型-股票 2016-07-26 131.46亿 0.04%  详情   159949 华安创业板50ETF 指数型-股票 2016-06-30 121.81亿 0.02%  详情   161726 招商国证生物医药指数(LOF)A 指数型-股票 2015-05-27 115.37亿 0.12%  详情   512760 国泰CES半导体芯片ETF 指数型-股票 2019-05-16 112.98亿 0.08%  详情   000051 华夏沪深300ETF联接A 指数型-股票 2009-07-10 111.98亿 0.07%  详情   510310 易方达沪深300发起式ETF 指数型-股票 2013-03-06 100.62亿 0.02%  详情   159901 易方达深证100ETF 指数型-股票 2006-03-24 97.67亿 0.02%  详情   512480 国联安中证半导体ETF 指数型-股票 2019-05-08 91.14亿 0.06%  详情   161028 富国中证新能源汽车指数(LOF)A 指数型-股票 2015-03-30 89.19亿 0.19%  详情   512900 南方中证全指证券公司ETF 指数型-股票 2017-03-10 85.94亿 0.03%  详情   159928 汇添富中证主要消费ETF 指数型-股票 2013-08-23 84.89亿 0.03%  详情   512800 华宝中证银行ETF 指数型-股票 2017-07-18 82.65亿 0.08%  详情   510810 汇添富中证上海国企ETF 指数型-股票 2016-07-28 81.34亿 0.06%  详情   160119 南方中证500ETF联接A 指数型-股票 2009-09-25 79.45亿 0.05%  详情   161024 富国中证军工指数(LOF)A 指数型-股票 2014-04-04 74.94亿 0.15%  详情   515030 华夏中证新能源汽车ETF 指数型-股票 2020-02-20 71.55亿 0.04%  详情   160222 国泰国证食品饮料行业(LOF) 指数型-股票 2014-10-23 70.9亿 0.18%  详情   512950 华夏中证央企ETF 指数型-股票 2018-10-19 70.21亿 0.03%  详情   512960 博时央企结构调整ETF 指数型-股票 2018-10-19 69.84亿 0.03%  详情   515330 天弘沪深300ETF 指数型-股票 2019-12-05 68.51亿 0.02%  详情   004070 南方中证全指证券公司ETF联接C 指数型-股票 2017-03-08 64.07亿 0.09%  详情   100038 富国沪深300指数增强 指数型-股票 2009-12-16 63.76亿 0.23%  详情   161604 融通深证100指数A 指数型-股票 2003-09-30 63.44亿 0.08%  详情   160630 鹏华国防A 指数型-股票 2014-11-13 62.63亿 0.15%  详情   001595 天弘中证银行ETF联接C 指数型-股票 2015-07-08 61.21亿 0.1%  详情   110020 易方达沪深300ETF联接A 指数型-股票 2009-08-26 60.98亿 0.07%  详情   501057 汇添富中证新能源汽车A 指数型-股票 2018-05-23 60.58亿 0.17%  详情   161017 富国中证500指数(LOF) 指数型-股票 2011-10-12 59.1亿 0.22%  详情   515000 华宝中证科技龙头ETF 指数型-股票 2019-07-22 58.85亿 0.04%  详情   512710 富国中证军工龙头ETF 指数型-股票 2019-07-23 58.47亿 0.03%  详情   512680 广发中证军工ETF 指数型-股票 2016-08-30 57.08亿 0.03%  详情   512170 华宝中证医疗ETF 指数型-股票 2019-05-20 57.03亿 0.04%  详情   050002 博时沪深300指数A 指数型-股票 2003-08-26 54.89亿 0.13%  详情   100032 富国中证红利指数增强A 指数型-股票 2008-11-20 54.03亿 0.16%  详情   000311 景顺长城沪深300指数增强 指数型-股票 2013-10-29 53.14亿 0.24%  详情   160632 鹏华酒A 指数型-股票 2015-04-29 51.75亿 0.17%  详情   515700 平安中证新能源汽车产业ETF 指数型-股票 2019-12-31 51.43亿 0.04%  详情   000248 汇添富中证主要消费ETF联接A 指数型-股票 2015-03-24 51.42亿 0.11%  详情   515380 泰康沪深300ETF 指数型-股票 2019-12-27 50.97亿 0.02%  详情   163407 兴全沪深300指数(LOF)A 指数型-股票 2010-11-02 50.07亿 0.31%  详情   110026 易方达创业板ETF联接A 指数型-股票 2011-09-20 49.76亿 0.11%  详情   001632 天弘中证食品饮料指数C 指数型-股票 2015-07-29 49.75亿 0.12%  详情   005693 广发中证军工ETF联接C 指数型-股票 2018-02-13 48.75亿 0.16%  详情   512400 南方中证申万有色金属ETF 指数型-股票 2017-08-03 46.74亿 0.02%  详情   008087 华夏中证5G通信主题ETF联接C 指数型-股票 2019-12-10 46.2亿 0.1%  详情   510230 国泰上证180金融ETF 指数型-股票 2011-03-31 45.66亿 0.06%  详情   512690 鹏华中证酒ETF 指数型-股票 2019-04-04 45.65亿 0.08%  详情   000478 建信中证500指数增强A 指数型-股票 2014-01-27 44.97亿 0.26%  详情   501058 汇添富中证新能源汽车C 指数型-股票 2018-05-23 43.7亿 0.17%  详情   515900 博时央企创新驱动ETF 指数型-股票 2019-09-20 43.16亿 0.04%  详情   005918 天弘沪深300ETF联接C 指数型-股票 2018-04-24 43.15亿 0.07%  详情   008086 华夏中证5G通信主题ETF联接A 指数型-股票 2019-12-10 41.5亿 0.1%  详情   007531 华宝券商ETF联接C 指数型-股票 2019-06-13 40.53亿 0.12%  详情   512500 华夏中证500ETF 指数型-股票 2015-05-05 39.75亿 0.02%  详情   012414 招商中证白酒指数(LOF)C 指数型-股票 2021-05-18 39.16亿 0.16%  详情   159994 银华中证5G通信主题ETF 指数型-股票 2020-01-22 37.48亿 0.04%  详情   159977 天弘创业板ETF 指数型-股票 2019-09-12 37.1亿 0.02%  详情   161026 富国中证国有企业改革指数 指数型-股票 2014-12-17 36.95亿 0.09%  详情   159905 工银深证红利ETF 指数型-股票 2010-11-05 36.94亿 0.03%  详情   001594 天弘中证银行ETF联接A 指数型-股票 2015-07-08 36.22亿 0.1%  详情   512980 广发中证传媒ETF 指数型-股票 2017-12-27 35.55亿 0.02%  详情   512070 易方达沪深300非银ETF 指数型-股票 2014-06-26 34.06亿 0.05%  详情   510350 工银瑞信沪深300ETF 指数型-股票 2019-05-20 33.59亿 0.02%  详情   159967 华夏创成长ETF 指数型-股票 2019-06-21 33.49亿 0.03%  详情   162412 华宝医疗ETF联接A 指数型-股票 2015-05-21 32.96亿 0.16%  详情   161720 招商中证全指证券公司指数(LOF) 指数型-股票 2014-11-13 32.21亿 0.1%  详情   159819 易方达中证人工智能主题ETF 指数型-股票 2020-07-27 31.46亿 0.05%  详情   160225 国泰国证新能源汽车指数 指数型-股票 2015-08-27 31.39亿 0.19%  详情   000613 国寿安保沪深300ETF联接 指数型-股票 2014-06-05 30.56亿 0.09%  详情   159992 银华中证创新药产业ETF 指数型-股票 2020-03-20 30.47亿 0.04%  详情   000961 天弘沪深300ETF联接A 指数型-股票 2015-01-20 30.32亿 0.07%  详情   007301 国联安中证半导体ETF联接C 指数型-股票 2019-06-26 30.28亿 0.2%  详情   510380 国寿安保沪深300ETF 指数型-股票 2018-01-19 29.78亿 0.03%  详情   167301 方正富邦保险主题指数 指数型-股票 2015-07-31 29.05亿 0.17%  详情   008888 华夏国证半导体芯片ETF联接C 指数型-股票 2020-06-02 28.94亿 0.13%  详情   001553 天弘中证证券保险C 指数型-股票 2015-06-30 28.83亿 0.09%  详情   001593 天弘创业板ETF联接基金C 指数型-股票 2015-07-08 28.46亿 0.1%  详情   001113 南方大数据100A 指数型-股票 2015-04-24 27.5亿 0.27%  详情   090010 大成中证红利指数A 指数型-股票 2010-02-02 27.39亿 0.09%  详情   160221 国泰国证有色金属行业指数(LOF) 指数型-股票 2015-03-30 27.26亿 0.17%  详情   515880 国泰中证全指通信设备ETF 指数型-股票 2019-08-16 26.88亿 0.04%  详情   515680 嘉实中证央企创新驱动ETF 指数型-股票 2019-09-20 26.79亿 0.04%  详情   164402 前海开源中航军工指数 指数型-股票 2015-03-30 26.46亿 0.19%  详情   512290 国泰中证生物医药ETF 指数型-股票 2019-04-18 26.41亿 0.08%  详情   510510 广发中证500ETF 指数型-股票 2013-04-11 26.13亿 0.02%  详情   159922 嘉实中证500ETF 指数型-股票 2013-02-06 25.98亿 0.02%  详情   000176 嘉实沪深300指数研究增强 指数型-股票 2014-12-26 24.74亿 0.18%  详情   510360 广发沪深300ETF 指数型-股票 2015-08-20 24.3亿 0.03%  详情   159948 南方创业板ETF 指数型-股票 2016-05-13 24.18亿 0.02%  详情   004746 易方达上证50增强C 指数型-股票 2017-06-06 23.82亿 0.37%  详情   512010 易方达沪深300医药ETF 指数型-股票 2013-09-23 23.81亿 0.03%  详情   163113 申万菱信中证申万证券行业指数 指数型-股票 2014-03-13 23.64亿 0.1%  详情   001052 华夏中证500ETF联接A 指数型-股票 2015-05-05 23.61亿 0.06%  详情   159959 银华中证央企结构调整ETF 指数型-股票 2018-10-22 23.42亿 0.04%  详情   519671 银河沪深300价值指数A 指数型-股票 2009-12-28 22.83亿 0.08%  详情   159820 天弘中证500ETF 指数型-股票 2020-08-07 22.8亿 0.12%  详情   008591 天弘中证全指证券公司ETF联接C 指数型-股票 2019-12-20 22.5亿 0.1%  详情   515800 添富中证800ETF 指数型-股票 2019-10-08 21.97亿 0.03%  详情   501016 国泰中证申万证券行业指数 指数型-股票 2017-04-27 21.92亿 0.14%  详情   008887 华夏国证半导体芯片ETF联接A 指数型-股票 2020-06-02 21.91亿 0.13%  详情   008282 国泰CES半导体芯片行业ETF联接C 指数型-股票 2019-11-22 21.65亿 0.2%  详情   040002 华安中国A股增强指数 指数型-股票 2002-11-08 21.6亿 0.28%  详情   515600 广发央企创新ETF 指数型-股票 2019-09-20 21.12亿 0.05%  详情   159940 广发中证全指金融地产ETF 指数型-股票 2015-03-23 21.02亿 0.05%  详情   512700 南方中证银行ETF 指数型-股票 2017-06-28 20.12亿 0.08%  详情   481009 工银沪深300指数A 指数型-股票 2009-03-05 19.84亿 0.07%  详情   012043 鹏华酒C 指数型-股票 2021-04-14 19.79亿 0.17%  详情   512580 广发中证环保ETF 指数型-股票 2017-01-25 19.59亿 0.04%  详情   512650 添富中证长三角ETF 指数型-股票 2019-07-26 19.58亿 0.03%  详情   159998 天弘中证计算机ETF 指数型-股票 2020-03-20 19亿 0.03%  详情   159939 广发中证全指信息技术ETF 指数型-股票 2015-01-08 18.59亿 0.02%  详情   161027 富国中证全指证券公司指数(LOF)A 指数型-股票 2015-03-27 18.39亿 0.14%  详情   501050 华夏上证50AH优选指数A 指数型-股票 2016-10-27 17.95亿 0.14%  详情   165520 信诚中证800有色指数(LOF) 指数型-股票 2013-08-30 17.72亿 0.22%  详情   006131 华泰柏瑞沪深300ETF联接C 指数型-股票 2018-07-02 17.71亿 0.08%  详情   481012 工银深证红利ETF联接A 指数型-股票 2010-11-09 17.48亿 0.1%  详情   512200 南方中证房地产ETF 指数型-股票 2017-08-25 17.37亿 0.07%  详情   159997 天弘中证电子ETF 指数型-股票 2020-02-27 17.22亿 0.04%  详情   159925 南方沪深300ETF 指数型-股票 2013-02-18 17.18亿 0.03%  详情   002656 南方创业板ETF联接A 指数型-股票 2016-05-20 17.11亿 0.1%  详情   159938 广发中证全指医药卫生ETF 指数型-股票 2014-12-01 16.92亿 0.02%  详情   110019 易方达深证100ETF联接A 指数型-股票 2009-12-01 16.91亿 0.09%  详情   159952 广发创业板ETF 指数型-股票 2017-04-25 16.61亿 0.03%  详情   159993 鹏华国证证券龙头ETF 指数型-股票 2019-12-26 16.38亿 0.06%  详情   159806 国泰中证新能源汽车ETF 指数型-股票 2020-03-10 16.28亿 0.06%  详情   160633 鹏华券商A 指数型-股票 2015-05-06 16.16亿 0.12%  详情   004069 南方中证全指证券公司ETF联接A 指数型-股票 2017-03-08 16.15亿 0.09%  详情   006020 广发沪深300指数增强A 指数型-股票 2018-06-29 16.1亿 0.2%  详情   510390 平安沪深300ETF 指数型-股票 2017-12-25 16.04亿 0.03%  详情   519300 大成沪深300指数A 指数型-股票 2006-04-06 15.89亿 0.2%  详情   501019 国泰国证航天军工指数 指数型-股票 2017-03-29 15.74亿 0.15%  详情   001631 天弘中证食品饮料指数A 指数型-股票 2015-07-29 15.64亿 0.12%  详情   515150 富国中证国企一带一路ETF 指数型-股票 2019-11-06 15.63亿 0.05%  详情   003318 景顺中证500行业中性低波动 指数型-股票 2017-03-03 15.4亿 0.07%  详情   004854 广发中证全指汽车指数A 指数型-股票 2017-07-31 15.24亿 0.18%  详情   001630 天弘中证计算机ETF联接C 指数型-股票 2015-07-29 15.23亿 0.08%  详情   270010 广发沪深300ETF联接A 指数型-股票 2008-12-30 15.16亿 0.08%  详情   160631 鹏华银行A 指数型-股票 2015-04-17 14.99亿 0.11%  详情   000962 天弘中证500ETF联接A 指数型-股票 2015-01-20 14.97亿 0.07%  详情   161723 招商中证银行指数 指数型-股票 2015-05-20 14.87亿 0.11%  详情   000008 嘉实中证500ETF联接A 指数型-股票 2013-03-22 14.62亿 0.06%  详情   003986 申万菱信中证500指数优选增强A 指数型-股票 2017-01-10 14.49亿 0.33%  详情   163115 申万菱信中证军工指数(LOF) 指数型-股票 2014-07-24 14.33亿 0.14%  详情   000596 前海开源中证军工指数A 指数型-股票 2014-05-27 14.19亿 0.18%  详情   161031 富国中证工业4.0指数(LOF) 指数型-股票 2015-06-15 14.16亿 0.12%  详情   001064 广发中证环保ETF联接A 指数型-股票 2015-03-25 14.1亿 0.13%  详情   512670 鹏华中证国防ETF 指数型-股票 2019-07-05 13.93亿 0.09%  详情   515650 富国中证消费50ETF 指数型-股票 2019-10-14 13.78亿 0.04%  详情   501311 嘉实港股通新经济指数A 指数型-股票 2019-01-14 13.68亿 0.28%  详情   007994 华夏中证500指数增强A 指数型-股票 2020-03-25 13.62亿 0.34%  详情   202015 南方沪深300联接基金A 指数型-股票 2009-03-25 13.58亿 0.06%  详情   162711 广发中证500ETF联接A 指数型-股票 2009-11-26 13.56亿 0.06%  详情   502023 鹏华国证钢铁行业指数(LOF)A 指数型-股票 2015-08-13 13.46亿 0.19%  详情   159801 广发国证半导体芯片ETF 指数型-股票 2020-01-20 13.37亿 0.03%  详情   161022 富国创业板指数(LOF)A 指数型-股票 2013-09-12 13.35亿 0.12%  详情   008281 国泰CES半导体芯片行业ETF联接A 指数型-股票 2019-11-22 13.2亿 0.2%  详情   001051 华夏上证50ETF联接A 指数型-股票 2015-03-17 13.18亿 0.07%  详情   020011 国泰沪深300指数A 指数型-股票 2007-11-11 13.17亿 0.08%  详情   110030 易方达沪深300量化增强 指数型-股票 2012-07-05 13.04亿 0.23%  详情   161121 易方达中证银行指数(LOF)A 指数型-股票 2015-06-03 12.97亿 0.11%  详情   007300 国联安中证半导体ETF联接A 指数型-股票 2019-06-26 12.87亿 0.2%  详情   510590 平安中证500ETF 指数型-股票 2018-03-23 12.78亿 0.03%  详情   515180 易方达中证红利ETF 指数型-股票 2019-11-26 12.54亿 0.08%  详情   519116 浦银安盛沪深300指数增强 指数型-股票 2010-12-10 12.42亿 0.19%  详情   000950 易方达沪深300非银联接A 指数型-股票 2015-01-22 12.4亿 0.1%  详情   502003 易方达中证军工(LOF)A 指数型-股票 2015-07-08 12.36亿 0.16%  详情   160219 国泰国证医药卫生行业指数 指数型-股票 2013-08-29 12.29亿 0.13%  详情   004752 广发中证传媒ETF联接A 指数型-股票 2018-01-02 12.22亿 0.1%  详情   159902 华夏中小企业100ETF 指数型-股票 2006-06-08 12.07亿 0.02%  详情   501048 汇添富中证全指证券公司指数C 指数型-股票 2017-12-04 12.02亿 0.1%  详情   001556 天弘中证500指数增强A 指数型-股票 2015-06-30 11.97亿 0.27%  详情   001469 广发中证全指金融地产联接A 指数型-股票 2015-07-09 11.91亿 0.09%  详情   160625 鹏华证券保险指数(LOF) 指数型-股票 2014-05-05 11.65亿 0.11%  详情   007464 交银创业板50指数A 指数型-股票 2019-11-20 11.56亿 0.14%  详情   006098 华宝券商ETF联接A 指数型-股票 2018-06-27 11.38亿 0.12%  详情   004789 富荣沪深300指数增强C 指数型-股票 2018-02-11 11.35亿 0.52%  详情   515660 国联安沪深300ETF 指数型-股票 2019-11-25 11.21亿 0.04%  详情   515070 华夏中证人工智能主题ETF 指数型-股票 2019-12-09 11.2亿 0.04%  详情   005223 广发中证基建工程ETF联接A 指数型-股票 2018-02-01 11.1亿 0.07%  详情   159807 易方达中证科技50ETF 指数型-股票 2020-03-16 11.04亿 0.04%  详情   515750 富国中证科技50策略ETF 指数型-股票 2019-11-15 11.03亿 0.03%  详情   160643 鹏华空天军工指数(LOF)A 指数型-股票 2017-06-13 10.97亿 0.18%  详情   515210 国泰中证钢铁ETF 指数型-股票 2020-01-22 10.96亿 0.1%  详情   510580 易方达中证500ETF 指数型-股票 2015-08-27 10.96亿 0.05%  详情   005224 广发中证基建工程ETF联接C 指数型-股票 2018-02-01 10.92亿 0.07%  详情   240014 华宝中证100指数A 指数型-股票 2009-09-29 10.87亿 0.08%  详情   513090 易方达中证香港证券投资ETF 指数型-股票 2020-03-13 10.82亿 0.25%  详情   002199 前海开源中证军工指数C 指数型-股票 2015-11-30 10.8亿 0.18%  详情   501009 汇添富中证生物科技指数A 指数型-股票 2016-12-22 10.79亿 0.1%  详情   502010 易方达中证全指证券公司指数(LOF)A 指数型-股票 2015-07-08 10.73亿 0.11%  详情   160420 华安创业板50指数 指数型-股票 2015-07-06 10.57亿 0.12%  详情   001618 天弘中证电子ETF联接C 指数型-股票 2015-07-29 10.55亿 0.09%  详情   001549 天弘上证50指数C 指数型-股票 2015-07-16 10.53亿 0.07%  详情   160716 嘉实基本面50指数(LOF)A 指数型-股票 2009-12-30 10.44亿 0.08%  详情   515110 易方达中证国企一带一路ETF 指数型-股票 2019-11-06 10.36亿 0.05%  详情   001180 广发医药卫生联接A 指数型-股票 2015-05-06 10.16亿 0.1%  详情   008889 银华中证5G通信主题ETF联接A 指数型-股票 2020-05-28 10.07亿 0.12%  详情   001552 天弘中证证券保险A 指数型-股票 2015-06-30 10.07亿 0.09%  详情   "},{"id":19,"href":"/note/docs/golang/go-pkg/","title":"go第三方库列表","section":"Go语言笔记","content":" go服务端开发中避免不了使用第三方库，因为第三方库可以避免重复造轮子，大大的提高了开发效率， 这篇文章收集了各种有意思的go语言第三方库，方便开发需要时查找\n 一款根据 sql 语句自动生成 Go 结构体的 chrome 插件。 #    sql2struct\n 一个将 curl 请求命令和数据格式转换为 Go 相关代码的在线服务。 #    url-to-Go\n 一个将 yaml 数据转换为 Go 结构体的在线服务。 #    yaml-to-Go\n 一个将 toml 数据转换为 Go 结构体的在线服务。 #    TOML-to-Go\n 一个将 json 数据转换为 Go 结构体的在线服务 #    JSON-to-Go\n 基于Websocket或者SockJS的实时通信平台 #    github.com/centrifugal/centrifugo  教程\n 开源的 Go 分布式事务框架 #    github.com/yedf/dtm\n 开源的推荐系统 #    github.com/zhenghaoz/gorse\n go语言实现的lua虚拟机 #    github.com/yuin/gopher-lua\n ElasticSearch Hook for Logrus #    github.com/sohlich/elogrus\n Actor模型go实现 #    github.com/AsynkronIT/protoactor-go\n Go便捷转换器（sql -\u0026gt; struct） #    github.com/airplayx/gormat\n Go语言的RPC服务治理框架 #    github.com/smallnest/rpcx\n go读取Excel表 #    github.com/qax-os/excelize\n go 爬虫框架colly #    github.com/gocolly/colly\n go底层操作系统交互补充包 #    github.com/golang/sys\n 双数组树go实现 #    github.com/adamzy/cedar-go\n go程序优雅重启 #    github.com/cloudflare/tableflip\n 基于zap封装的log包 #    github.com/georgehao/log\n go一致性哈希包 #    github.com/stathat/consistent\n bilibili开源IM框架 #    github.com/Terry-Mao/goim\n golang tcp 框架（仿gin） #    https://github.com/fwhezfwhez/tcpx\n 基于Reactor模式的非阻塞TCP网络库 #    github.com/Allenxuxu/gev\n go分布式服务框架 #    github.com/skynetservices/skynet-archive\n sql代码生成：sqlc #    github.com/kyleconroy/sqlc\n go http路由 #    github.com/gorilla/mux\n go 测试库: gostub #    github.com/prashantv/gostub\n 唯一id生成golang库 #    github.com/satori/go.uuid\n golang缓存库： gcache #    github.com/bluele/gcache\n go jwt认证 #    github.com/dgrijalva/jwt-go\n go爬虫辅助，收集页面所有url #    github.com/JackDanger/collectlinks\n bilibili开源微服务框架：Kratos #    github.com/go-kratos/kratos\n go-micro微服务框架 #    github.com/micro/go-micro\n go web 框架：neo #   github.com/ivpusic/neo\ngim聊天系统 #    github.com/alberliu/gim\n mysql同步elasticsearch #    github.com/go-mysql-org/go-mysql-elasticsearch\n 左倾红黑树 #    github.com/petar/GoLLRB\n oklog #    github.com/oklog/oklog\n golang时间库：carbon #    github.com/uniplaces/carbon\n go协程池：ants #    github.com/panjf2000/ants\n go基准测试框架 #    github.com/fperf/fperf\n go-kit代码生成器 #    github.com/metaverse/truss\n 中文分词 #    github.com/huichen/sego\n 生成带文字的png图片 #    github.com/golang/freetype\n chart图表库 #    github.com/wcharczuk/go-chart\n 人脸识别库 #    github.com/Kagami/go-face\n"},{"id":20,"href":"/note/docs/database/mongodb/","title":"MongoDB的一些操作记录","section":"数据库相关","content":" 本文记录MongoDB使用过程中，因需求需要进行一些不常用的操作，如创建用户，导出数据，数据备份恢复等运维层面的技术知识， 后续有遇到继续往文章后面添加，以备不时之需，可来此进行查阅\n  MongoDB创建用户  # 用户名xxx, 密码123, 角色权限：readWrite(读写), 数据库：xxx db.createUser({user:\u0026#39;xxx\u0026#39;, pwd:\u0026#39;123\u0026#39;, roles:[{ role: \u0026#34;readWrite\u0026#34;, db: \u0026#34;xxx\u0026#34; }]})  MongoDB导出数据  # 数据库：xxxdb, 用户名：xxx, 密码：123, 表名：players, -f 需要导出的字段... --type=csv(导出格式) -o ./data.csv(导出路径) mongoexport -d xxxdb -u xxx -p 123 -c players -f _id,data.ip,data.createTime,data.lastLoginTime,data.resource.1,data.resource.2,data.resource.4,data.VideoTotal,data.withdraw.withdrawTotal --type=csv -o ./data.csv # 导出的Excel表中时间戳转成时间字符串 =TEXT((C2+8*3600)/86400+70*365+19,\u0026#34;yyyy-mm-dd hh:mm:ss\u0026#34;)  MongoDB备份数据  # 数据库名： xxxdb, 用户名：xxx, 密码： 123, 备份文件路径：/root/workspace/mongo/backup mongodump -d xxxdb -o /root/workspace/mongo/backup -u xxx -p 123 "},{"id":21,"href":"/note/docs/nginx/nginxop/","title":"Nginx命令操作记录","section":"Nginx","content":" 重新load配置 nginx -s reload 热部署   先替换nginx二进制文件，然后发送kill -USR2 进程号，会启动新master 的进程\n然后向老进程发送信号让其优雅的关闭work进程 kill -WINCH 进程号 , 老的master进程会保留防止回退\n "},{"id":22,"href":"/note/docs/other/mac/","title":"其他记录","section":"其他笔记","content":" 其他杂乱的操作记录，供必要时查阅\n Mac app损坏：\n#  sudo xattr -r -d com.apple.quarantine /Applications/CleanMyMac\\ X.app/\n好用插件记录 #   Annotate 具体到每一行代码是谁提交的 "},{"id":23,"href":"/note/docs/material/reference/","title":"参考博客文献","section":"学习资料","content":" 本文收集一下博客文献的链接，供学习参考\n    golang gin demo\n   go高效直播服务器\n   go学习资源合集\n   验证码生成go实现\n   go学习线路图\n   简易图像服务器go实现\n   书籍《go语言高级编程》在线阅读\n   RabbitMQ高频面试题\n   Elasticsearch学习笔记\n   linux awk命令使用教程\n "},{"id":24,"href":"/note/docs/interview/interview/","title":"面经","section":"面试相关笔记","content":" 这里记录2020年5月以来的面试经历，主要是一些技术相关的面试问答，如没有答案的可根据问题自行百度答案， 后续会不断补充完整\n 游乐学 #  2020-05\n 小孩子教学类游戏\n  golang怎么管理调度协程的 go指针和c++指针的区别 golang内存泄漏有哪些情况？ 数组和slice的区别 项目有没有用redis作缓存 Linux下怎么调试找bug 用什么命令查看Linux下一个端口的状态  lsof -i :port_number |grep \u0026quot;(LISTEN)\u0026quot; netstat  怎么查找/替换指定目录下所有文件的指定内容  sed -i s/yyyy/xxxx/g `grep yyyy -rl --include=\u0026quot;*.txt\u0026quot; ./`  点云（心娱） #  2020-06\n 游戏+直播\n  项目经验 遇到的难题以及解决方法   信言 #  2020-06\n 狼人杀\n  红黑树 MySQL事务 gRPC的具体内容 TCP/IP协议 40亿个不同的数排序（桶排序，一个比特位一个桶）   数字广东 #  2020-07\n 驻数字广东的外包人员\n  协程之间的同步和锁 channel的使用 项目架构图 登录流程 如何防止多次登录请求 单链表反转 C++和golang的区别 map的底层实现 游戏AI控制脚本的设计模式 项目进程间通信的协议HTTP还是socket   银月互娱 （offer） #  2020-07\n 赌博类游戏app，海外外包\n  解耦（场景：同时生成很多张照片）【降低两者之间的联系】 多协程读写map注意事项【加锁】 new和make的区别【make针对slice，map， chan】 面向对象通过什么实现（组合/继承/接口）【golang 使用组合的方式实现继承 ，从而实现面向对象】 MongoDB索引 MongoDB聚合 slice是否可以作为map键 s为字符串，是s[0]表示啥？ 同时广播消息给10万个socket 项目架构图 defer输出顺序 重写父类函数 程序找问题：未初始化map waitGroup死锁问题   聚游网络 （offer） #  2020-07\n 网赚类轻度休闲手游\n  啥都没问  艾美科技 #  2021-04-08\n 投币式K歌机\n  快排 介绍最拿手的项目 会员登录服怎么去设计实现 MongoDB objectID 抛出异常， 怎么向上级抛出异常 怎么捕获异常 defer的什么时候输出， sys.Exit()还会不会输出 树的遍历方式   金山电话一面 #  2021-04-10\n wps办公软件\n  自我介绍 golang的面向对象 golang的多态怎么实现（不同的结构体实现同一个接口） golang的闭包，闭包的概念 golang自己实现读写锁 channal底层实现 字符串里的字符统计 golang内存逃逸 数组和切片的区别 golang程序有没有做性能监控（比如协程的数量） init函数，只使用包的init函数怎么导入包 进程间怎么通信（rpc） linux 查询筛选今天的日志 查询端口占用情况 资源占用高怎么排查问题 MySQL索引，B+树的时间复杂度，B+树和B树的区别 MongoDB分片（3个节点，6个分片，数据是怎么样的） MongoDB和Redis的区别 怎么解决缓存一致性 缓存击穿 数据库中配置数据忘了提交，导致缓存穿透怎么优化 redis发布订阅 Redis分布式锁怎么实现 线上服部署的流程 有没有用过大数据相关，推荐算法 微服务的理解 自己项目架构是怎样的？有什么弊端？ make和new的区别 Elasticsearch的分片 有没有用过Elasticsearch数据从MySQL导入 测试服不同版本怎么隔离 场景优化：电商大量图片经常被请求，带宽过高怎么优化？ 场景优化：大量读写配置怎么降低QPS 你们项目的QPS多高？ 你有什么要问我们的吗？   致悦科技 #  2021-04-10\n 卡牌手游\n  没面试，过去当主程  木木互娱 #  2021-04-15\n 游戏，CDN开发\n  协程，高并发   千音科技 #  2021-04-15\n 视频直播\n  redis集群 redis事务 "},{"id":25,"href":"/note/docs/interview/plan/","title":"面试准备","section":"面试相关笔记","content":" 每次面试都需要做好充分的准备，这篇文章就是作为面试前准备的复习文档，每次面试前后都会不断优化迭代此文档，供以后使用\n Golang #  go协程 #   协程之间的同步的几种方法  互斥锁: Mutex channel （生产消费模型） WaitGroup （add, done和wait）  golang怎么管理调度协程的?  基于GPM模型实现 goroutine 并非传统意义上的协程，现在主流的线程模型分三种：内核级线程模型、用户级线程模型和两级线程模型（也称混合型线程模型），传统的协程库属于用户级线程模型，而 goroutine 和它的 Go Scheduler 在底层实现上其实是属于两级线程模型。 在 Go 语言中，每一个 goroutine 是一个独立的执行单元，相较于每个 OS 线程固定分配 2M 内存的模式，goroutine 的栈采取了动态扩容方式， 初始时仅为2KB，随着任务执行按需增长，最大可达 1GB（64 位机器最大是 1G，32 位机器最大是 256M），且完全由 golang 自己的调度器 Go Scheduler 来调度。此外，GC 还会周期性地将不再使用的内存回收，收缩栈空间。 因此，Go 程序可以同时并发成千上万个 goroutine 是得益于它强劲的调度器和高效的内存模型。 //----------------------------------------------------------------------- GPM G: 表示 Goroutine，每个 Goroutine 对应一个 G 结构体，G 存储 Goroutine 的运行堆栈、状态以及任务函数，可重用。G 并非执行体，每个 G 需要绑定到 P 才能被调度执行。 P: Processor，表示逻辑处理器， 对 G 来说，P 相当于 CPU 核，G 只有绑定到 P(在 P 的 local runq 中)才能被调度。对 M 来说，P 提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，P 的数量决定了系统内最大可并行的 G 的数量（前提：物理 CPU 核数 \u0026gt;= P 的数量），P 的数量由用户设置的 GOMAXPROCS 决定，但是不论 GOMAXPROCS 设置为多大，P 的数量最大为 256。 M: Machine，OS 线程抽象，代表着真正执行计算的资源，在绑定有效的 P 后，进入 schedule 循环；而 schedule 循环的机制大致是从 Global 队列、P 的 Local 队列以及 wait 队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础，M 的数量是不定的，由 Go Runtime 调整，为了防止创建过多 OS 线程导致系统调度不过来，目前默认最大限制为 10000 个。 每个 P 维护一个 G 的本地队列； 当一个 G 被创建出来，或者变为可执行状态时，就把他放到 P 的本地可执行队列中，如果满了则放入Global； 当一个 G 在 M 里执行结束后，P 会从队列中把该 G 取出；如果此时 P 的队列为空，即没有其他 G 可以执行， M 就随机选择另外一个 P，从其可执行的 G 队列中取走一半。  当通过 go 关键字创建一个新的 goroutine 的时候，它会优先被放入 P 的本地队列。为了运行 goroutine，M 需要持有（绑定）一个 P，接着 M 会启动一个 OS 线程，循环从 P 的本地队列里取出一个 goroutine 并执行。执行调度算法：当 M 执行完了当前 P 的 Local 队列里的所有 G 后，P 也不会就这么在那划水啥都不干，它会先尝试从 Global 队列寻找 G 来执行，如果 Global 队列为空，它会随机挑选另外一个 P，从它的队列里中拿走一半的 G 到自己的队列中执行。 用户态阻塞/唤醒 当 goroutine 因为 channel 操作阻塞时，对应的 G 会被放置到某个 wait 队列(如 channel 的 waitq)，该 G 的状态由_Gruning 变为 _Gwaitting ，而 M 会跳过该 G 尝试获取并执行下一个 G，如果此时没有 runnable 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态；当阻塞的 G 被另一端的 G2 唤醒时（比如 channel 的可读/写通知），G 被标记为 runnable，尝试加入 G2 所在 P 的 runnext，然后再是 P 的 Local 队列和 Global 队列。  主协程如何等其余协程完再操作  用channel控制 用sync.WaitGroup  golang内存泄漏有哪些情况？  外部资源是不可以GC掉的，如：打开文件，数据库，http请求等 短时间内实例化过多对象等  channel的使用 go指针和c++指针的区别  c++指针可以做算术运算  C++和golang的区别 数组和slice的区别 map的底层实现  散列表，即哈希表  多协程读写map注意事项  加锁  slice是否可以作为map键  map key 必须是可比较的类型，语言规范中定义了可比较的类型：boolean, numeric, string, pointer, channel, interface, 以及仅包含这些类型的struct和array 。不能作为map key的类型有：slice，map, function。  new和make的区别  make针对slice，map， chan new返回的是指向Type的指针。 make直接返回的是Type类型值 总结： new会分配结构空间，并初始化为清空为零，不进一步初始化 new之后需要一个指针来指向这个结构 make会分配结构空间及其附属空间，并完成其间的指针初始化 make返回这个结构空间，不另外分配一个指针   面向对象通过什么实现（组合/继承/接口）  golang 使用组合的方式实现继承 ，从而实现面向对象  defer输出顺序  FILO，后进先出，即下到上 最先声明的最后输出  select用于干什么？  用于处理异步IO问题  context包的用途  用于控制goroutine的生命周期。 当一个计算任务被goroutine承接了之后，由于某种原因（超时，或者强制退出） 我们希望中止这个goroutine的计算任务，那么就用得到这个Context了。  sync.pool  为了复用已经使用过的对象，来达到优化内存使用和回收的目的  重写父类函数 waitGroup死锁问题 项目进程间通信的协议HTTP还是socket s为字符串，是s[0]表示啥？  如果 s 是一个字符串，那么s[0] 表示 s 的第一个 byte，长度固定：1个字节。  同时广播消息给10万个socket   gin源码解读 #   Linux #   用什么命令查看Linux下一个端口的状态  答： lsof -i :端口号 | grep \u0026quot;(LISTEN)\u0026quot; // 查看对应端口的占用情况 netstat -nultp // 查看所有端口的占用情况 netstat -anp | grep 端口号 // 查看对应端口的占用情况  怎么查找/替换指定目录下所有文件的指定内容  sed -i s/yyyy/xxxx/g `grep yyyy -rl --include=\u0026quot;*.txt\u0026quot; ./`  MySQL #   MySQL事务  在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。 事务用来管理 insert,update,delete 语句 // ----------------------------------------------------- 原子性： 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性： 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性： 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。  MySQL主键索引和辅助索引的区别 inonedb为啥用b+树  为什么说B+树比B树更适合数据库索引？ 1、 B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。 2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。 PS：我在知乎上看到有人是这样说的,我感觉说的也挺有道理的： 他们认为数据库索引采用B+树的主要原因是：B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。  索引分析 MySQL联合索引 分表（水平分表，垂直分表） 有一张表，有商店ID，既要按照商店查询，也要按照商品查询。求分表策略。 MySQL深翻页问题如何解决， limit m, n   MongoDB #   MongoDB索引 聚合   Redis #  Redis缓存 #   缓存穿透 缓存雪崩 缓存一致性问题  Redis队列 #  哈希表实现原理（Redis的哈希表扩容） #  Redis分布式锁 #  Redis zrange复杂度 #   TiDB #   RabbitMQ #   Elasticsearch #   Etcd #   Nginx #   TCP/IP #   与udp的区别  tcp传输的是数据流，而udp是数据包，tcp会进过三次握手，udp不需要  HTTP #   http完整请求 错误码  400 bad request，请求报文存在语法错误 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 403 forbidden，表示对请求资源的访问被服务器拒绝 404 not found，表示在服务器上没有找到请求的资源  WebSocket #   websocket 不支持并发写   protobuf #   protobuf和json比较的优势   rpc #   gRpc的具体内容 rpc通信的协议是HTTP还是socket   shell #   数据结构 #  红黑树 #  B树的性质 #  定义任意非叶子结点最多只有M个儿子，且M\u0026gt;2； 根结点的儿子数为[2, M]； 除根结点以外的非叶子结点的儿子数为[M/2, M]； 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字） 非叶子结点的关键字个数=指向儿子的指针个数-1； 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] \u0026lt; K[i+1]； 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树； 所有叶子结点位于同一层； B+树的性质(下面提到的都是和B树不相同的性质) #  非叶子节点的子树指针与关键字个数相同； 非叶子节点的子树指针p[i],指向关键字值属于[k[i],k[i+1]]的子树.(B树是开区间,也就是说B树不允许关键字重复,B+树允许重复)； 为所有叶子节点增加一个链指针； 所有关键字都在叶子节点出现(稠密索引). (且链表中的关键字恰好是有序的)； 非叶子节点相当于是叶子节点的索引(稀疏索引),叶子节点相当于是存储(关键字)数据的数据层； 更适合于文件系统；  为什么MySQL数据库索引选择使用B+树？\n其他 #  解耦 （场景：同时生成很多张照片）【降低两者之间的联系】 #  稳定排序和不稳定排序 #  RBAC模型的分析与实现 #  RBAC全称为基于角色的访问控制模型（Role-based access control），在该模型中，通过让权限与角色关联来实现授权，给用户分配一系列的角色来让注册用户得到这些角色对应的权限，使系统权限分配更加方便。我们在一般的大型系统开发中，几乎都要考虑权限控制的相关问题，诸如：系统资源权限、用户行为权限等，此类问题的实现通常需要数据库在设计时做出考虑，经过IT届各种大佬的长期实践后，总结出了较为通用的针对权限控制的RBAC设计模型。RBAC不是某种技术框架，它类似于设计模式，是当下流行的一种数据库（表）设计的思想，它能通过为用户分配角色来实现权限的分配，只要你的数据库设计满足这种思想便可说你的数据库使用的是RBAC模型。  面试题 #    40亿个不同的数排序 桶排序，一个比特位一个桶\n  单链表反转\n  给定a,b两个文件，各存放50亿个url，每个url各占64字节，内存限制4G，让你找出a, b文件共同url\n "},{"id":26,"href":"/note/docs/interview/faq/","title":"面试灵魂拷问","section":"面试相关笔记","content":" 本文收集一些面试golang服务端开发的问题和答案，以及一些知识点的参考文章等，让即将面试的小伙伴有佛脚可抱。 包括但不限于Linux， golang， 数据库， nginx， etcd， Redis， http， 消息队列，等等。\n 问答集 #   Q1: Linux的磁盘管理   Q2: Linux有哪些进程通信方式，五大件   Q3: Linux的共享内存如何实现，大概说了一下   Q4: 共享内存实现的具体步骤   Q5: socket网络编程，说一下TCP的三次握手和四次挥手   Q6:如何把docker讲的很清楚   Q7:cgroup在linux的具体实现   Q8:多线程用过哪些   Q9:MySQL索引的实现，innodb的索引，b+树索引是怎么实现的，为什么用b+树做索引节点，一个节点存了多少数据，怎么规定大小，与磁盘页对应   Q10:MySQL的事务隔离级别，分别解决什么问题   Q11:Redis了解么，如果Redis有1亿个key，使用keys命令是否会影响线上服务，我说会，因为是单线程模型，可以部署多个节点。   Q12:知不知道有一条命令可以实现上面这个功能   Q13:Redis的持久化方式，aod和rdb，具体怎么实现，追加日志和备份文件，底层实现原理   Q14:Redis的list是怎么实现的，我说用ziplist+quicklist实现的，ziplist压缩空间，quicklist实现链表   Q15:sortedset怎么实现的，使用dict+skiplist实现的，问我skiplist的数据结构，大概说了下是个实现简单的快速查询结构。   Q16:了解什么消息队列，rmq和kafka   Q17:线程池   Q18:操作系统的进程通信方式，僵尸进程和孤儿进程是什么，如何避免僵尸进程，我说让父进程显示通知，那父进程怎么知道子进程结束了   Q19:计算机网络TCP和UDP有什么区别，为什么迅雷下载是基于UDP的，我说FTP是基于TCP，而迅雷是p2p不需要TCP那么可靠的传输保证。   Q20:操作系统的死锁必要条件，如何避免死锁   Q21:写一个LRU的缓存，需要完成超时淘汰和LRU淘汰。   Q22: get和post的区别？ A： https://blog.csdn.net/kebi007/article/details/103059900\n  Q23: Redis 问题集 A： https://blog.csdn.net/Design407/article/details/103242874\n  Q24: 消息中间件面试题31道RabbitMQ+ActiveMQ+Kafka A: https://www.jianshu.com/p/0a322b2bba2a\n"},{"id":27,"href":"/note/docs/golang/channel/","title":"channel注意事项","section":"Go语言笔记","content":" channel是go语言编程中必不可少的元素，但对不同状态的channel作read，write和close操作会有不同的结果， 稍有操作不当，将导致系统 panic，所以本文介绍了channel不同状态的操作结果\n channel不同状态的操作结果： #     操作 channel状态 结果     Read nil 阻塞    打开且非空 输出值    打开但空 阻塞    关闭的 \u0026lt;默认值\u0026gt;, false    只写 编译错误   -     Write nil 阻塞    打开的但填满 阻塞    打开的且不满 写入值    关闭的 panic    只读 编译错误   -     close nil panic    打开且非空 关闭channel；读取成功，直到通道耗尽，然后读取产生的默认值    打开但空 关闭channel；读到生产者的默认值    关闭的 panic    只读 编译错误   "},{"id":28,"href":"/note/docs/elasticsearch/elasticsearch-install/","title":"Elasticsearch部署","section":"Elasticsearch","content":" Elasticsearch是一个开源的分布式、RESTful 风格的搜索和数据分析引擎，它的底层是开源库Apache Lucene。 Lucene 可以说是当下最先进、高性能、全功能的搜索引擎库——无论是开源还是私有，但它也仅仅只是一个库。 本文记录Linux上Elasticsearch的安装配置等部署流程\n 下载Elasticsearch #  wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.9.2-linux-x86_64.tar.gz 创建用户 #  groupadd esGroup useradd user -g esGroup -p password 权限分配 #  cd /usr/local chown -R esUser:esGroup elasticsearch-7.1.0 vim /etc/security/limits.conf * soft nofile 65536 * hard nofile 65536 修改系统配置 #  vim /etc/sysctl.conf vm.max_map_count=262144 sysctl -p 修改elasticsearch配置(重点关注7项) #  # ======================== Elasticsearch Configuration ========================= # # NOTE: Elasticsearch comes with reasonable defaults for most settings. # Before you set out to tweak and tune the configuration, make sure you # understand what are you trying to accomplish and the consequences. # # The primary way of configuring a node is via this file. This template lists # the most important settings you may want to configure for a production cluster. # # Please consult the documentation for further information on configuration options: # https://www.elastic.co/guide/en/elasticsearch/reference/index.html # # ---------------------------------- Cluster ----------------------------------- # # Use a descriptive name for your cluster: # cluster.name: yourscat-es-cluster //-------------(1)--------------------- # # ------------------------------------ Node ------------------------------------ # # Use a descriptive name for the node: # node.name: node-1 //-------------(2)--------------------- # # Add custom attributes to the node: # #node.attr.rack: r1 # # ----------------------------------- Paths ------------------------------------ # # Path to directory where to store the data (separate multiple locations by comma): # path.data: /usr/local/elasticsearch-7.1.0/data //-------------(3)--------------------- # # Path to log files: # path.logs: /usr/local/elasticsearch-7.1.0/logs //-------------(4)--------------------- # # ----------------------------------- Memory ----------------------------------- # # Lock the memory on startup: # #bootstrap.memory_lock: true # # Make sure that the heap size is set to about half the memory available # on the system and that the owner of the process is allowed to use this # limit. # # Elasticsearch performs poorly when the system is swapping the memory. # # ---------------------------------- Network ----------------------------------- # # Set the bind address to a specific IP (IPv4 or IPv6): # network.host: 0.0.0.0 //-------------(5)--------------------- # # Set a custom port for HTTP: # http.port: 9200 //-------------(6)--------------------- # # For more information, consult the network module documentation. # # --------------------------------- Discovery ---------------------------------- # # Pass an initial list of hosts to perform discovery when this node is started: # The default list of hosts is [\u0026quot;127.0.0.1\u0026quot;, \u0026quot;[::1]\u0026quot;] # #discovery.seed_hosts: [\u0026quot;host1\u0026quot;, \u0026quot;host2\u0026quot;] # # Bootstrap the cluster using an initial set of master-eligible nodes: # cluster.initial_master_nodes: [\u0026quot;node-1\u0026quot;] //-------------(7)--------------------- # # For more information, consult the discovery and cluster formation module documentation. # # ---------------------------------- Gateway ----------------------------------- # # Block initial recovery after a full cluster restart until N nodes are started: # #gateway.recover_after_nodes: 3 # # For more information, consult the gateway module documentation. # # ---------------------------------- Various ----------------------------------- # # Require explicit names when deleting indices: # #action.destructive_requires_name: true 启动elasticsearch #  bin/elasticsearch -d 部署elasticHD #  yum install xdg-utils "},{"id":29,"href":"/note/docs/golang/sync/","title":"golang sync包的使用","section":"Go语言笔记","content":" go sync 包在go语言并发编程中必不可少，本文介绍go sync包中各个接口的使用方法以及示例\n type Once #  功能: 确保函数只执行一次\n结构定义：\ntype Once struct { // contains filtered or unexported fields } //function list： func (o *Once) Do(f func()) 用法示例：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { var once sync.Once var two sync.Once onceBody := func() { fmt.Println(\u0026#34;Only once\u0026#34;) } twoBody := func() { fmt.Println(\u0026#34;two once\u0026#34;) } done := make(chan bool) for i := 0; i \u0026lt; 10; i++ { go func() { once.Do(onceBody) done \u0026lt;- true }() } for i := 0; i \u0026lt; 10; i++ { \u0026lt;-done } two.Do(twoBody) two.Do(twoBody) } 输出：\nOnly once two once  type WaitGroup #  功能： 用于等待协程结束，每起一个goroutine之前Add(1),每个goroutine完成退出前Done()，主线程中用Wait()阻塞等待所有goroutine退出。\n结构定义：\ntype WaitGroup struct { // contains filtered or unexported fields } //function list: // 计数器增加delta，表示增加delta个goroutine func (wg *WaitGroup) Add(delta int) // 计数器减1，表示一个goroutine执行完成 func (wg *WaitGroup) Done() // 挂起等待计数器归零 func (wg *WaitGroup) Wait() 示例：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func tt(wg *sync.WaitGroup, i int) { defer wg.Done() fmt.Printf(\u0026#34;goroutine: %d\\n\u0026#34;, i) } func main() { wg := \u0026amp;sync.WaitGroup{} for i := 0; i \u0026lt; 10; i++ { wg.Add(1) go tt(wg, i) } wg.Wait() fmt.Println(\u0026#34;Run end!\u0026#34;) } 输出：\ngoroutine: 9 goroutine: 6 goroutine: 7 goroutine: 8 goroutine: 3 goroutine: 2 goroutine: 4 goroutine: 1 goroutine: 5 goroutine: 0 Run end!  type Locker #  功能： 确保资源只被一个goroutine占有\n结构定义：\ntype Locker interface { Lock() // 上锁，在已锁的状态下此函数阻塞，直到锁被释放  Unlock() // 用于释放锁，在无锁的状态下执行会报错 } 示例：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func tt(w *sync.WaitGroup, l *sync.Mutex, i int) { defer func() { fmt.Printf(\u0026#34;End Goroutine: %d\\n\u0026#34;, i) l.Unlock() w.Done() }() l.Lock() fmt.Printf(\u0026#34;lock: %d\\n\u0026#34;, i) time.Sleep(time.Second) } func main() { l := \u0026amp;sync.Mutex{} w := \u0026amp;sync.WaitGroup{} for i := 0; i \u0026lt; 10; i++ { w.Add(1) go tt(w, l, i) } w.Wait() fmt.Println(\u0026#34;Run end!\u0026#34;) } 输出：\nlock: 1 End Goroutine: 1 lock: 9 End Goroutine: 9 lock: 2 End Goroutine: 2 lock: 3 End Goroutine: 3 lock: 4 End Goroutine: 4 lock: 5 End Goroutine: 5 lock: 6 End Goroutine: 6 lock: 7 End Goroutine: 7 lock: 8 End Goroutine: 8 lock: 0 End Goroutine: 0 Run end!  type RWMutex #  功能： RWMutex 是单写多读锁，读锁占用的情况下会阻止写，不会阻止读，多个goroutine可以同时获取读锁，写锁会阻止其他goroutine（无论读和写）进来，整个锁由该 goroutine独占，适用于读多写少的场景.\nPS：读共享，写独占，写优先\n结构定义：\ntype RWMutex struct { // contains filtered or unexported fields } //function list func (rw *RWMutex) Lock() // 写加锁 func (rw *RWMutex) RLock() // 读加锁 // 返回一个实现Lock和Unlock方法的Locker接口，用于调用rw.RLock和rw.RUnlock来实现读锁的加锁和解锁。 func (rw *RWMutex) RLocker() Locker func (rw *RWMutex) RUnlock() // 读解锁 func (rw *RWMutex) Unlock() // 写解锁 示例：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var value int func writes(i int, wg *sync.WaitGroup, rwM *sync.RWMutex) { defer wg.Done() for { rand.Seed(time.Now().Unix()) num := rand.Intn(100) rwM.Lock() value = num fmt.Printf(\u0026#34;writes goroutine:%d, Write num=%d\\n\u0026#34;, i, num) rwM.Unlock() time.Sleep(time.Second * time.Duration(i+1)) } } func readRLocker(i int, wg *sync.WaitGroup, rwM *sync.RWMutex) { defer wg.Done() w := rwM.RLocker() for { w.Lock() num := value fmt.Printf(\u0026#34;readRLocker goroutine:%d, Reading num=%d\\n\u0026#34;, i, num) time.Sleep(time.Second * 2) w.Unlock() time.Sleep(time.Second * 1) } } func read2(i int, wg *sync.WaitGroup, rwM *sync.RWMutex) { defer wg.Done() for { rwM.RLock() num := value fmt.Printf(\u0026#34;read2 goroutine:%d, Reading num=%d\\n\u0026#34;, i, num) time.Sleep(time.Second * 2) rwM.RUnlock() time.Sleep(time.Second * 1) } } func main() { rwMutex := \u0026amp;sync.RWMutex{} wg := \u0026amp;sync.WaitGroup{} for i := 0; i \u0026lt; 5; i++ { wg.Add(1) go writes(i, wg, rwMutex) } for i := 0; i \u0026lt; 10; i++ { wg.Add(1) go readRLocker(i, wg, rwMutex) } for i := 0; i \u0026lt; 10; i++ { wg.Add(1) go read2(i, wg, rwMutex) } wg.Wait() } 输出：\nwrites goroutine:1, Write num=70 read2 goroutine:1, Reading num=70 read2 goroutine:6, Reading num=70 read2 goroutine:9, Reading num=70 read2 goroutine:7, Reading num=70 read2 goroutine:8, Reading num=70 read2 goroutine:4, Reading num=70 readRLocker goroutine:4, Reading num=70 readRLocker goroutine:1, Reading num=70 readRLocker goroutine:0, Reading num=70 readRLocker goroutine:8, Reading num=70 readRLocker goroutine:3, Reading num=70 readRLocker goroutine:2, Reading num=70 readRLocker goroutine:5, Reading num=70 readRLocker goroutine:9, Reading num=70 readRLocker goroutine:6, Reading num=70 read2 goroutine:2, Reading num=70 read2 goroutine:0, Reading num=70 read2 goroutine:3, Reading num=70 readRLocker goroutine:7, Reading num=70 read2 goroutine:5, Reading num=70 writes goroutine:0, Write num=70 writes goroutine:3, Write num=70 writes goroutine:2, Write num=70 writes goroutine:4, Write num=70 writes goroutine:1, Write num=93 readRLocker goroutine:5, Reading num=93 readRLocker goroutine:8, Reading num=93 read2 goroutine:4, Reading num=93 read2 goroutine:9, Reading num=93 read2 goroutine:7, Reading num=93 read2 goroutine:2, Reading num=93 read2 goroutine:8, Reading num=93 read2 goroutine:5, Reading num=93 readRLocker goroutine:0, Reading num=93 readRLocker goroutine:1, Reading num=93 readRLocker goroutine:3, Reading num=93 readRLocker goroutine:2, Reading num=93 readRLocker goroutine:4, Reading num=93 ··· ···  type Cond  #  功能：\n Broadcase、Signal 唤醒因wait condition而挂起goroutine，Signal只唤醒一个，而Broadcast唤醒所有。允许调用者获取基础锁Locker之后再调用唤醒，但非必需。\n  Wait 必须获取该锁之后才能调用Wait()方法，Wait方法在调用时会释放底层锁Locker，并且将当前goroutine挂起，直到另一个goroutine执行Signal或者Broadcase，该goroutine才有机会重新唤醒，并尝试获取Locker，完成后续逻辑。\n 结构定义：\ntype Cond struct { // L is held while observing or changing the condition  L Locker // contains filtered or unexported fields } //function list: func NewCond(l Locker) *Cond func (c *Cond) Broadcast() // 广播唤醒所有wait func (c *Cond) Signal() // 唤醒其中一个wait func (c *Cond) Wait() // 进入等待状态，释放锁 示例：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func tt(cd *sync.Cond, wg *sync.WaitGroup, i int) { defer wg.Done() cd.L.Lock() fmt.Printf(\u0026#34;lock: %d\\n\u0026#34;, i) cd.Wait() fmt.Printf(\u0026#34;wait end: %d\\n\u0026#34;, i) cd.L.Unlock() } func main() { l := \u0026amp;sync.Mutex{} w := \u0026amp;sync.WaitGroup{} cd := sync.NewCond(l) for i := 0; i \u0026lt; 10; i++ { w.Add(1) go tt(cd, w, i) } time.Sleep(time.Second) fmt.Println(\u0026#34;Send 5 Signal:\u0026#34;) for i := 0; i \u0026lt; 5; i++ { cd.Signal() //唤醒一个wait中的goroutine \t} time.Sleep(time.Second) fmt.Println(\u0026#34;Send Broadcast:\u0026#34;) cd.Broadcast() //广播唤醒所有wait中的goroutine \tw.Wait() fmt.Println(\u0026#34;Run end!\u0026#34;) } 输出：\nlock: 1 lock: 2 lock: 7 lock: 8 lock: 9 lock: 0 lock: 3 lock: 6 lock: 5 lock: 4 Send 5 Signal: wait end: 7 wait end: 9 wait end: 2 wait end: 8 wait end: 1 Send Broadcast: wait end: 4 wait end: 0 wait end: 3 wait end: 6 wait end: 5 Run end!  type Pool #  功能： Pool 是可伸缩、并发安全的临时对象池，用来存放已经分配但暂时不用的临时对象，通过对象重用机制，缓解 GC 压力，提高程序性能。\nPS：如果你使用的Pool代码所需的东西不是大概同质的，那么从Pool中转化检索到所需要的内容的时间可能比重新实例化内容要花费的时间更多。\n结构定义：\ntype Pool struct { // New optionally specifies a function to generate  // a value when Get would otherwise return nil.  // It may not be changed concurrently with calls to Get.  New func() interface{} // contains filtered or unexported fields } //function list: func (p *Pool) Get() interface{} //从 Pool 中获取元素，元素数量 -1，当 Pool 中没有元素时，会调用 New 生成元素，新元素不会放入 Pool 中，若 New 未定义，则返回 nil func (p *Pool) Put(x interface{}) // 把用完的元素放回Pool中 示例：\npackage poolTest import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; ) func connectToService() interface{} { time.Sleep(1 * time.Second) return struct {}{} } func startNetworkDaemon() *sync.WaitGroup { var wg sync.WaitGroup wg.Add(1) go func() { connPool := warmServiceConnCache() server, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:8080\u0026#34;) if err != nil { log.Fatalf(\u0026#34;cannot listen: %v\u0026#34;, err) } defer server.Close() wg.Done() for { conn, err := server.Accept() if err != nil { log.Printf(\u0026#34;cannot accept connection: %v\u0026#34;, err) } svcConn := connPool.Get() fmt.Fprintln(conn, \u0026#34;\u0026#34;) connPool.Put(svcConn) conn.Close() } }() return \u0026amp;wg } func init() { daemonStarted := startNetworkDaemon() daemonStarted.Wait() } func BenchmarkNetworkRequest(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { conn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:8080\u0026#34;) if err != nil { b.Fatalf(\u0026#34;cannot dial host: %v\u0026#34;, err) } if _, err := ioutil.ReadAll(conn); err != nil { b.Fatalf(\u0026#34;cannot read: %v\u0026#34;, err) } conn.Close() } } func warmServiceConnCache() *sync.Pool { p := \u0026amp;sync.Pool{ New: connectToService, } for i := 0; i \u0026lt; 10; i++ { p.Put(p.New()) } return p } 输出：\ngoos: darwin goarch: amd64 pkg: go-bfzd/poolTest BenchmarkNetworkRequest-4 1000 10610437 ns/op PASS ok go-bfzd/poolTest 38.099s  type Map #  功能： sync.Map这个数据结构是线程安全的（基本类型Map结构体在并发读写时会panic严重错误），它填补了Map线程不安全的缺陷，不过最好只在需要的情况下使用。它一般用于并发模型中对同一类map结构体的读写，或其他适用于sync.Map的情况。\n结构定义：\ntype Map struct { // contains filtered or unexported fields } //function list: func (m *Map) Delete(key interface{}) // 删除对应key的值 func (m *Map) Load(key interface{}) (value interface{}, ok bool) // 获取key对应的值 func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool) //获取对应key的值，成功则返回true和value，不存在该key则将值存进该key并返回false和存进去的value func (m *Map) Range(f func(key, value interface{}) bool) // 遍历map中的所有key func (m *Map) Store(key, value interface{}) // 将value存进对应的key，存在则覆盖 示例：\n// sync.Map是线程安全的，一般用于并发模型中，本例不存在并发，只演示各个接口的用法  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { sMap := sync.Map{} fmt.Println(\u0026#34;=====================Store=======================\u0026#34;) fmt.Println(\u0026#34;store: key=1, value=jay\u0026#34;) sMap.Store(1, \u0026#34;jay\u0026#34;) fmt.Println(\u0026#34;store: key=2, value=lhj\u0026#34;) sMap.Store(2, \u0026#34;lhj\u0026#34;) fmt.Println(\u0026#34;store: key=2, value=lhj-hhh\u0026#34;) sMap.Store(2, \u0026#34;lhj-hhh\u0026#34;) fmt.Println(\u0026#34;=====================LoadOrStore=======================\u0026#34;) result, succeed := sMap.LoadOrStore(1, \u0026#34;jays\u0026#34;) fmt.Printf(\u0026#34;key=1 store: value=jays; result: load_succeed=%t, value=%v\\n\u0026#34;, succeed, result) result, succeed = sMap.LoadOrStore(2, \u0026#34;lhj-s\u0026#34;) fmt.Printf(\u0026#34;key=2 store: value=lhj-s; result: load_succeed=%t, value=%v\\n\u0026#34;, succeed, result) result, succeed = sMap.LoadOrStore(3, \u0026#34;jay-lhj\u0026#34;) fmt.Printf(\u0026#34;key=3 store: value=jay-lhj; result: load_succeed=%t, value=%v\\n\u0026#34;, succeed, result) fmt.Println(\u0026#34;=====================Load key:1~4=======================\u0026#34;) if val, ok := sMap.Load(1); ok { fmt.Printf(\u0026#34;key=1, value=%v\\n\u0026#34;, val) }else { fmt.Printf(\u0026#34;key=1, load failed\\n\u0026#34;) } if val, ok := sMap.Load(2); ok { fmt.Printf(\u0026#34;key=2, value=%v\\n\u0026#34;, val) }else { fmt.Printf(\u0026#34;key=2, load failed\\n\u0026#34;) } if val, ok := sMap.Load(3); ok { fmt.Printf(\u0026#34;key=3, value=%v\\n\u0026#34;, val) }else { fmt.Printf(\u0026#34;key=3, load failed\\n\u0026#34;) } if val, ok := sMap.Load(4); ok { fmt.Printf(\u0026#34;key=4, value=%v\\n\u0026#34;, val) }else { fmt.Printf(\u0026#34;key=4, load failed\\n\u0026#34;) } fmt.Println(\u0026#34;======================Delete======================\u0026#34;) fmt.Println(\u0026#34;delete key=1\u0026#34;) sMap.Delete(1) fmt.Println(\u0026#34;=====================Range=======================\u0026#34;) sMap.Range(func(key, value interface{}) bool { fmt.Printf(\u0026#34;key=%v value=%v\\n\u0026#34;, key, value) return true }) } 输出：\n=====================Store======================= store: key=1, value=jay store: key=2, value=lhj store: key=2, value=lhj-hhh =====================LoadOrStore======================= key=1 store: value=jays; result: load_succeed=true, value=jay key=2 store: value=lhj-s; result: load_succeed=true, value=lhj-hhh key=3 store: value=jay-lhj; result: load_succeed=false, value=jay-lhj =====================Load key:1~4======================= key=1, value=jay key=2, value=lhj-hhh key=3, value=jay-lhj key=4, load failed ======================Delete====================== delete key=1 =====================Range======================= key=2 value=lhj-hhh key=3 value=jay-lhj "},{"id":30,"href":"/note/docs/golang/study-line/","title":"go服务端开发学习指南","section":"Go语言笔记","content":" 本文介绍基于go语言的服务端程序开发学习指南，根据列举的知识点自行学习，所列知识点都是开发基础必备技术栈。\n 熟练Linux系统的使用 #   Linux的基本命令操作 必须熟练Linux系统的使用，才能得心应手的部署自己开发的服务端程序。 shell脚本的编写 编写一下自动化脚本，用于控制服务器的一些自动操作，如起停服，备份，批量操作文件等等。 系统其他配置等 熟悉Linux系统和一些常用软件的配置等，才能让系统更加适配自己的服务端程序的运行，即运行环境的配置。 make和Makefile等 makefile用于配置程序的编译法则，make即编译程序 ps：基础学习可以参考： 菜鸟教程  语言基础 #   golang的语法学习： golang菜鸟教程  数据结构与算法 #   队列，大顶堆，小顶堆，红黑树，字典树 八大排序算法，雪花算法等 缓存的过期策略：FIFO，LRU，LFU等  数据库 #    Redis 用于做缓存,队列,主题订阅发布等\n  MongoDB 结构化不强的数据存储\n  MySQL 结构化数据存储\n  etcd 服务注册与发现\n  Elasticsearch 搜索，数据分析\n  开发框架 #   gin go-kit go-zero kratos beego gRpc zap  架构知识 #   分布式 微服务  其他知识点 #   rpc protobuf http TCP websocket Docker Kubernetes  golang工程师学习之路 # "},{"id":31,"href":"/note/docs/golang/grace-exit/","title":"go程序优雅退出","section":"Go语言笔记","content":" 服务端程序是持续不断运行的，在停服时就需要等待各种服务关闭后再退出程序， 本文将介绍go程序优雅退出目前比较推荐的一种实现方式\n 原理 #  通过go1.16+的NotifyContext方法和errgroup包实现服务的优雅停止\n代码 #  package main import ( \u0026#34;context\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;golang.org/x/sync/errgroup\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os/signal\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;time\u0026#34; ) type ginHttp struct { server *http.Server } func NewGinHttpServer(listenIp string, listenPort int, f func(engine *gin.Engine)) *ginHttp { engine := gin.Default() f(engine) s := \u0026amp;http.Server{ Addr: fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, listenIp, listenPort), Handler: engine, } return \u0026amp;ginHttp{ server: s, } } func (g *ginHttp) Serve() \u0026lt;-chan error { // chan长度大于等于1， 不然errch不存在读取取，将永远阻塞在这里，造成goroutine泄露 \terrch := make(chan error, 1) go func() { err := g.server.ListenAndServe() if err != nil { errch \u0026lt;- err log.Printf(\u0026#34;服务停止：%v\u0026#34;, err) } close(errch) }() return errch } func (g *ginHttp) Stop() error { ctx, cancel := context.WithTimeout(context.Background(), time.Second*10) defer cancel() return g.server.Shutdown(ctx) } func main() { // 创建通过监听信号syscall.SIGINT, syscall.SIGEMT来停止的context \tctx, cancel := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGEMT) defer cancel() // 通过errgroup来运行多个服务 \tg, ctx := errgroup.WithContext(ctx) // 服务一 \tg.Go(func() error { tr := time.NewTimer(time.Second * 30) select { // 监听context是否被取消， 取消则终止服务 \tcase \u0026lt;-ctx.Done(): /* 停止服务操作 stop() */ log.Println(\u0026#34;收到context取消信号，停止服务一\u0026#34;) return ctx.Err() // 模拟服务 \tcase \u0026lt;-tr.C: // 模拟30秒后服务出错返回， errgroup会对errgroup.WithContext返回的context进行取消 \tlog.Println(\u0026#34;服务一出错： xxx\u0026#34;) return errors.New(\u0026#34;xxx\u0026#34;) } }) // 服务二： 基于gin框架的web服务 \tg.Go(func() error { ginSvr := NewGinHttpServer(\u0026#34;0.0.0.0\u0026#34;, 8080, func(engine *gin.Engine) { engine.GET(\u0026#34;/hello\u0026#34;, func(c *gin.Context) { c.String(http.StatusOK, \u0026#34;Hello World!\u0026#34;) }) }) select { // 监听context是否被取消， 取消则终止服务 \tcase \u0026lt;-ctx.Done(): //停止服务操作 \tlog.Println(\u0026#34;收到context取消信号，停止服务二\u0026#34;) err := ginSvr.Stop() if err != nil { log.Printf(\u0026#34;停止服务二出错： %v\u0026#34;, err) } else { log.Println(\u0026#34;成功停止服务二\u0026#34;) } return ctx.Err() // http服务 \tcase err := \u0026lt;-ginSvr.Serve(): // 如果服务完成并未出错， errgroup不会对返回的context进行取消操作 \tif err != nil { log.Printf(\u0026#34;服务二出错： %v\u0026#34;, err) } return err } }) // 等待所有服务完成，或者某个服务报错并终止所有服务 \terr := g.Wait() log.Printf(\u0026#34;程序退出：%v\u0026#34;, err) } "},{"id":32,"href":"/note/docs/golang/eventhub/","title":"go程序发布监听事件库","section":"Go语言笔记","content":" 这是一个开源的用于golang程序内部发布和监听事件的package， 其原理是通过定义一个全局变量存储监听的事件id和对应的handle函数， 当发布事件时，通过事件id查找对应的handle，如果找到则执行该handle函数。\n 使用说明 #  安装 #  go get github.com/jageros/eventhub\n使用 #  监听事件 #   seq := eventhub.Subscribe(eventID, handle) eventID为事件id， 返回的seq为序列号，两者都是int型， handle原型为func(args \u0026hellip;interface{}){}，args参数类型为interface{}型，通过事件发布函数传入\n 发布事件 #   eventhub.Publish(eventID, arg1, arg2 ··· ) eventID为事件id， argx为参数，将传给事件监听的handle\n 取消监听 #   Unsubscribe(eventID int, seq int) eventID为事件id， seq为序列号，序列从监听事件函数返回值获得\n 使用示例 #  github.com/jageros/eventhub/example/main.go\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/jageros/eventhub\u0026#34; ) func main() { // 监听事件 \teventhub.Subscribe(2, func(args ...interface{}) { fmt.Printf(\u0026#34;Subscribe1 eventId=2 args=%v\\n\u0026#34;, args) }) eventhub.Subscribe(1, func(args ...interface{}) { fmt.Printf(\u0026#34;Subscribe2 eventId=1 args=%v\\n\u0026#34;, args) }) eventhub.Subscribe(3, func(args ...interface{}) { fmt.Printf(\u0026#34;Subscribe3 eventId=3 args=%v\\n\u0026#34;, args) if arg, ok := args[0].(func()); ok { arg() } }) // 监听并取消监听 \tseq := eventhub.Subscribe(1, func(args ...interface{}) { fmt.Printf(\u0026#34;Subscribe4 eventId=1 args=%+v\\n\u0026#34;, args) }) eventhub.Unsubscribe(1, seq) // 发布事件 \teventhub.Publish(1, 10, 100) eventhub.Publish(2, 20, 200) eventhub.Publish(3, test) } // 此函数用作参数 func test() { fmt.Printf(\u0026#34;End!\\n\u0026#34;) } 源码解释 #  eventhub.go\npackage eventhub import ( \u0026#34;fmt\u0026#34; ) var ( maxSeq = 0 // 序列号 \tlisteners = make(map[int][]*listener) // map[事件id][]handleFunc ) type listener struct { seq int handler func(args ...interface{}) } /**************************************************************** * func：监听事件函数 * eventID： 事件id * handler： 事件函数 * return seq ： 该事件当前handle的序列号， 用于取消监听时参数 ***************************************************************/ func Subscribe(eventID int, handler func(args ...interface{})) (seq int) { maxSeq++ seq = maxSeq ln := \u0026amp;listener{ seq: seq, handler: handler, } ls, ok := listeners[eventID] if !ok { ls = []*listener{} } listeners[eventID] = append(ls, ln) return seq } /******************************************* * func： 发布事件 * eventID 事件id * args 给handle传的参数 * return nil *******************************************/ func Publish(eventID int, args ...interface{}) { ls, ok := listeners[eventID] if !ok { return } for _, l := range ls { catchPanic(func() { l.handler(args...) }) } } /************************************* * func： 取消监听 * eventID 事件ID * seq 事件序列号 （ps：因为一个事件可能存在多个handle函数） * return nil *************************************/ func Unsubscribe(eventID int, seq int) { ls, ok := listeners[eventID] if !ok { return } index := -1 for i, l := range ls { if l.seq == seq { index = i break } } if index \u0026gt;= 0 { listeners[eventID] = append(ls[:index], ls[index+1:]...) } } /******************************************* * func： 对执行的handle捕获异常并恢复 * f 需要执行法人函数 * return err 执行f返回的错误 *******************************************/ func catchPanic(f func()) (err interface{}) { defer func() { err = recover() if err != nil { fmt.Printf(\u0026#34;eventhub func panic: %s\u0026#34;, err) } }() f() return } "},{"id":33,"href":"/note/docs/linux/operate-recode/","title":"Linux不常用操作记录","section":"Linux","content":" 本文记录在使用Linux系统过程中，遇到的一些不常用的，需要查询的，难以记忆的操作命令， 方便以后再次使用的时候，可以翻阅查询，节省查找时间，提高开发效率\n 批量重命名图片 #  let n=0; for i in *.jpg; do mv $i $n.jpg; n=`expr $n + 1`; done 递归删除指定类型文件 #  find . -name \u0026#34;*.rej\u0026#34; |xargs rm -f 批量修改文件指定内容 #  将文件中的gopkg.in/mgo.v2/bson修改成go.mongodb.org/mongo-driver/bson\n# --include=*.go 表示指定文件类型 grep gopkg.in/mgo.v2/bson -rl --include=*.go ./* | xargs sed -i \u0026#34;s#gopkg.in/mgo.v2/bson#go.mongodb.org/mongo-driver/bson#g\u0026#34; # 或 sed -i \u0026#34;s#gopkg.in/mgo.v2/bson#go.mongodb.org/mongo-driver/bson#g\u0026#34; `grep gopkg.in/mgo.v2/bson -rl --include=\u0026#34;*.go\u0026#34; ./` 查看端口占用 #  lsof -i:8080 # 或 netstat -pan | grep 8080 #netstat 中参数选项 #-a或--all：显示所有连线中的Socket；  #-A\u0026lt;网络类型\u0026gt;或--\u0026lt;网络类型\u0026gt;：列出该网络类型连线中的相关地址；  #-c或--continuous：持续列出网络状态；  #-C或--cache：显示路由器配置的快取信息；  #-e或--extend：显示网络其他相关信息；  #-F或--fib：显示FIB；  #-g或--groups：显示多重广播功能群组组员名单；  #-h或--help：在线帮助；  #-i或--interfaces：显示网络界面信息表单；  #-l或--listening：显示监控中的服务器的Socket；  #-M或--masquerade：显示伪装的网络连线；  #-n或--numeric：直接使用ip地址，而不通过域名服务器；  #-N或--netlink或--symbolic：显示网络硬件外围设备的符号连接名称；  #-o或--timers：显示计时器；  #-p或--programs：显示正在使用Socket的程序识别码和程序名称；  #-r或--route：显示Routing Table；  #-s或--statistice：显示网络工作信息统计表；  #-t或--tcp：显示TCP传输协议的连线状况；  #-u或--udp：显示UDP传输协议的连线状况；  #-v或--verbose：显示指令执行过程；  #-V或--version：显示版本信息；  #-w或--raw：显示RAW传输协议的连线状况；  #-x或--unix：此参数的效果和指定\u0026#34;-A unix\u0026#34;参数相同；  #--ip或--inet：此参数的效果和指定\u0026#34;-A inet\u0026#34;参数相同。 修改终端显示信息 #   配置文件： /etc/bashrc\n PS1=”[\\u@\\h \\w]$” \\d ：代表日期，格式为weekday month date，例如：”Mon Aug 1” \\H ：完整的主机名称。例如：我的机器名称为：fc4.linux，则这个名称就是fc4.linux \\h ：仅取主机的第一个名字，如上例，则为fc4，.linux则被省略 \\t ：显示时间为24小时格式，如：HH：MM：SS \\T ：显示时间为12小时格式 \\A ：显示时间为24小时格式：HH：MM \\u ：当前用户的账号名称 \\v ：BASH的版本信息 \\w ：完整的工作目录名称。家目录会以 ~代替 \\W ：利用basename取得工作目录名称，所以只会列出最后一个目录 # ：下达的第几个命令 $ ：提示字符，如果是root时，提示符为：# ，普通用户则为：$ 查看系统参数 #  # 查看Linux版本 cat /proc/version # 查看Linux发行版本 cat /etc/redhat-release # 查看CPU型号及参数 cat /proc/cpuinfo | grep model # 查看磁盘空间 df -h # 查看内存和交换空间 free -[k/m/g] #k/m/g分别表示以kb，mb，gb为单位显示`` # 查看系统位数 getconf LONG_BIT linux文件修改权限 #  命令: chmod ABC file 其中A、B、C各为一个数字，分别表示User、Group、及Other的权限。 A、B、C这三个数字如果各自转换成由“0”、“1”组成的二进制数，则二进制数的每一位分别代表一个角色的读、写、运行的权限。比如User组的权限A： 如果可读、可写、可运行，就表示为二进制的111，转换成十进制就是7。 如果可读、可写、不可运行，就表示为二进制的110，转换成十进制就是6。 如果可读、不可写、可运行，就表示为二进制的101，转换成十进制就是5。 “4=r,2=w,1=x”的意思是： r 代表读，w 代表写，x 代表执行， 如果可读，权限是二进制的100，十进制是4； 如果可写，权限是二进制的010，十进制是2； 如果可运行，权限是二进制的001，十进制是1； 具备多个权限，就把相应的 4、2、1 相加就可以了： 若要 rwx 则 4+2+1=7 若要 rw- 则 4+2=6 若要 r-x 则 4+1=5 若要 r-- 则 =4 若要 -wx 则 2+1=3 若要 -w- 则 =2 若要 --x 则 =1 若要 --- 则 =0 为不同的角色分配不同的权限，放在一起，就出现 777、677这样的数字了。 你也可以用 chmod u+x file 的方式为User组添加执行权限。 chmod +x file 是为当前用户添加执行权限 "},{"id":34,"href":"/note/docs/nginx/nginx-limit/","title":"Nginx IP 限流","section":"Nginx","content":" 通过对同一IP进行限流，在一定程度上可以防止应用层DDOS攻击。本文介绍 Nginx对同一IP限流的配置\n nginx.conf配置文件 #  http { ...... # 在http节点中添加下面这一行 limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; server { # 在server节点中添加这一行 limit_req zone=one burst=10 nodelay;; ...... } } limit_req_zone的参数详解:\nbinary_remote_addr：表示客户端ip地址的二进制，当此nginx前方还存在代理时，需进行处理.\nzone=one:10m：为session会话状态分配一个大小为10m内存存储区，并且设定名称为one.\nrate=1r/s：表示请求频率不能超过每秒一次.\n limit_req的参数详解:\nzone=one：表示这个server服务收到的请求放在one的那个内存区域，等待被处理.\nburst=10：表示请求队列的长度，比如我设置了rate=1r/s，而同一时刻有15个请求发过来，那么第一个请求会被处理，10个请求会被存在队列里等待被处理，而剩下4个请求就会直接响应503状态码。\nnodelay：表示不延时。比如rate=1r/s，如果不设置nodelay就会严格按照1秒处理一个请求的频率，直观的看就是页面数据卡了，过了一秒后才加载出来。\n 这里有人就会疑惑了，既然nodelay设置不延时，那么设置处理频率rate=1r/s又有什么意义呢?\n我们假设一个案例来做分析：\n 设置rate=1r/s，burst=10，nodelay不延时，然后同时有15个请求发过来，其中一个请求被处理的时候，有10个请求会在队列中等待，而另外4个请求就会直接响应503状态码。由于设置了nodelay，一旦处理完一个请求之后立刻就会处理队列中的下一个请求。在1秒钟内，队列钟的请求全部都被处理完了，但是这个时候队列中的请求并不会被清除掉，而是会等到满1秒钟后才会被清除。这期间如果还有请求发来，由于队列中的请求并没有被清除，所以直接就响应503。\n "},{"id":35,"href":"/note/docs/nginx/proxy/","title":"nginx反向代理","section":"Nginx","content":" 利用Nginx的反向代理可以实现多个域名指向同个服务器的不同网站，本文将介绍如何配置\n nginx反向代理配置 #  第一个站点\nserver { listen 443; server_name www.jayg.xyz; ssl on; ssl_certificate /home/www/ssl/1_www.jayg.xyz_bundle.crt; ssl_certificate_key /home/www/ssl/2_www.jayg.xyz.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; location / { proxy_pass http://127.0.0.1:8080; } error_page 500 502 503 504 404 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } 第二个站点\nserver { listen 443 ssl; server_name www.hawtech.cn; ssl_certificate /home/www/ssl/1_www.hawtech.cn_bundle.crt; ssl_certificate_key /home/www/ssl/2_www.hawtech.cn.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; location / { proxy_pass http://127.0.0.1:8081; } error_page 500 502 503 504 404 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } "},{"id":36,"href":"/note/docs/golang/queue/","title":"queue golang实现","section":"Go语言笔记","content":" 本文介绍go语言gopkg.in/eapache/queue包的原理，代码解析以及使用方法\n 说明 #   本文主要介绍golang queue 库：gopkg.in/eapache/queue的实现原理和使用。\n第三方开源库获取： go get gopkg.in/eapache/queue.v1 使用时导入： import \u0026quot;gopkg.in/eapache/queue.v1\u0026quot;\n 原理 #   队列的缓存区为环形，实际是一个数组，当队头元素取出后，队头标志会往后移动，空出的位置可存储队尾新加元素，当队尾增加元素时，队尾标志向后移动，当缓存区我末尾没有位置时，队尾标志从0开始，复用队头取出元素空出的位置，直到当缓存区满后，缓存区空间成倍增长【ps: resize中的newBuf := make([]interface{}, q.count\u0026lt;\u0026lt;1)】，队列元素复制到缓存区的开始区域，当队列元素数量减为缓存区1/4的时候，缓存区空间重置为元素个数的两倍长度，同时队列元素复制到缓存区的开始区域。\n 函数功能 #  queue.New()返回一个长度为16的空队列 queue.Add(elem)为入队，即向队列中添加元素 queue.Remove()为出队列操作，返回一个队头元素 queue.Peek()返回队头元素，但元素不出队 queue.Get(i)返回队列中第i个元素，但不从队列中删除  源码解读 #  ps： 该库主要是这个文件： queue.go，源码不多，开发者可根据需求修改后使用\n/* Package queue provides a fast, ring-buffer queue based on the version suggested by Dariusz Górecki. Using this instead of other, simpler, queue implementations (slice+append or linked list) provides substantial memory and time benefits, and fewer GC pauses. The queue implemented here is as fast as it is for an additional reason: it is *not* thread-safe. */ package queue // minQueueLen is smallest capacity that queue may have. // Must be power of 2 for bitwise modulus: x % n == x \u0026amp; (n - 1). const minQueueLen = 16 // 队列缓存区最小长度  // Queue represents a single instance of the queue data structure. type Queue struct { buf []interface{} // 缓存区 \thead, tail, count int // 队头下标，队尾下标，队列长度 } // New constructs and returns a new Queue. func New() *Queue { return \u0026amp;Queue{ buf: make([]interface{}, minQueueLen), // 返回最小长度缓存的空队列 \t} } // Length returns the number of elements currently stored in the queue. func (q *Queue) Length() int { return q.count // 队列长度 } // resizes the queue to fit exactly twice its current contents // this can result in shrinking if the queue is less than half-full func (q *Queue) resize() { newBuf := make([]interface{}, q.count\u0026lt;\u0026lt;1) // 将队列缓存区长度重设为队列长度的两倍  // 复制元素到缓存区开始区域 \tif q.tail \u0026gt; q.head { copy(newBuf, q.buf[q.head:q.tail]) } else { // 因为是环形缓存区，需要先复制缓存区后半部分，即队列前半部分，再复制缓存区前半部分，即队尾部分 \tn := copy(newBuf, q.buf[q.head:]) copy(newBuf[n:], q.buf[:q.tail]) } q.head = 0 // 队头下标置0 \tq.tail = q.count // 队尾下标为队列长度（此下标为下一个元素插入的下标） \tq.buf = newBuf // 新队列 } // Add puts an element on the end of the queue. func (q *Queue) Add(elem interface{}) { if q.count == len(q.buf) { q.resize() // 新元素入队之前，当队列长度等于缓存区长度时，缓存区长度重设为两个队列长度 \t} q.buf[q.tail] = elem // 入队 \t// bitwise modulus \tq.tail = (q.tail + 1) \u0026amp; (len(q.buf) - 1) // 队尾下标在缓存环中移动一位 \tq.count++ // 队列长度+1 } // Peek returns the element at the head of the queue. This call panics // if the queue is empty. func (q *Queue) Peek() interface{} { if q.count \u0026lt;= 0 { panic(\u0026#34;queue: Peek() called on empty queue\u0026#34;) } return q.buf[q.head] // 返回队头元素，不出队 } // Get returns the element at index i in the queue. If the index is // invalid, the call will panic. This method accepts both positive and // negative index values. Index 0 refers to the first element, and // index -1 refers to the last. func (q *Queue) Get(i int) interface{} { // If indexing backwards, convert to positive index. \tif i \u0026lt; 0 { i += q.count // 支持负数，从队列尾部开始 \t} if i \u0026lt; 0 || i \u0026gt;= q.count { panic(\u0026#34;queue: Get() called with index out of range\u0026#34;) } // bitwise modulus \treturn q.buf[(q.head+i)\u0026amp;(len(q.buf)-1)] // 返回队列的第i个元素 \t// 因为数环形缓存区，队尾可能在缓存去前半部分，所以需要与一下队列最大下标 } // Remove removes and returns the element from the front of the queue. If the // queue is empty, the call will panic. func (q *Queue) Remove() interface{} { if q.count \u0026lt;= 0 { panic(\u0026#34;queue: Remove() called on empty queue\u0026#34;) } ret := q.buf[q.head] // 出队 \tq.buf[q.head] = nil // bitwise modulus \tq.head = (q.head + 1) \u0026amp; (len(q.buf) - 1) // 队头下标在环形缓存区后移一位 \tq.count-- // 队列长度减一 \t// Resize down if buffer 1/4 full. \tif len(q.buf) \u0026gt; minQueueLen \u0026amp;\u0026amp; (q.count\u0026lt;\u0026lt;2) == len(q.buf) { q.resize() // 重置缓存区大小，当队列长度减小到缓存区长度1/4的时候，但不可小于最小长度16 \t} return ret } 测试 #   打印缓存区数据，查看缓存区大小变化：\n先在queue.go中添加打印函数\nfunc (q *Queue) LookData() { fmt.Println(q.buf) }  测试代码main.go\npackage main import ( \u0026#34;test_code/queue\u0026#34; ) func main() { que := queue.New() for i := 0; i \u0026lt; 16; i++ { que.Add(i) que.LookData() } for i := 0; i \u0026lt; 5; i++ { que.Remove() que.LookData() } for i := 0; i \u0026lt; 5; i++ { que.Add(i) que.LookData() } que.Add(100) que.LookData() for i := 0; i \u0026lt; 16; i++ { que.Remove() que.LookData() } } 输出：\n[0 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [0 1 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [0 1 2 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [0 1 2 3 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [0 1 2 3 4 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [0 1 2 3 4 5 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [0 1 2 3 4 5 6 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [0 1 2 3 4 5 6 7 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [0 1 2 3 4 5 6 7 8 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [0 1 2 3 4 5 6 7 8 9 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [0 1 2 3 4 5 6 7 8 9 10 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [0 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [0 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [0 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;nil\u0026gt;] [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15] [\u0026lt;nil\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15] [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 2 3 4 5 6 7 8 9 10 11 12 13 14 15] [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 3 4 5 6 7 8 9 10 11 12 13 14 15] [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 4 5 6 7 8 9 10 11 12 13 14 15] [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 5 6 7 8 9 10 11 12 13 14 15] [0 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 5 6 7 8 9 10 11 12 13 14 15] [0 1 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 5 6 7 8 9 10 11 12 13 14 15] [0 1 2 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 5 6 7 8 9 10 11 12 13 14 15] [0 1 2 3 \u0026lt;nil\u0026gt; 5 6 7 8 9 10 11 12 13 14 15] [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15] [5 6 7 8 9 10 11 12 13 14 15 0 1 2 3 4 100 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [\u0026lt;nil\u0026gt; 6 7 8 9 10 11 12 13 14 15 0 1 2 3 4 100 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 7 8 9 10 11 12 13 14 15 0 1 2 3 4 100 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 8 9 10 11 12 13 14 15 0 1 2 3 4 100 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 9 10 11 12 13 14 15 0 1 2 3 4 100 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 10 11 12 13 14 15 0 1 2 3 4 100 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 11 12 13 14 15 0 1 2 3 4 100 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 12 13 14 15 0 1 2 3 4 100 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 13 14 15 0 1 2 3 4 100 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [14 15 0 1 2 3 4 100 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [\u0026lt;nil\u0026gt; 15 0 1 2 3 4 100 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 0 1 2 3 4 100 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 1 2 3 4 100 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 2 3 4 100 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 3 4 100 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 4 100 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 100 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] "},{"id":37,"href":"/note/docs/algorithm/random-n-int/","title":"生成x个随机数","section":"算法知识","content":" 需求：生成x个随机数，要求这个x个随机数的和为y， 且随机数的最大值小于平均数的3倍，最小值大于0，例如：5个和为10的随机数避免出现6，1，1，1，1的情况。 【使用场景：游戏中卡牌包开包时随机出现卡牌质量的分布】\n本文展示go语言对该算法的实现\n 代码实现 #  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;sort\u0026#34; \u0026#34;time\u0026#34; ) func main() { rand.Seed(time.Now().Unix()) // 用时间初始化种子 \tfor i := 0; i \u0026lt; 10; i++ { // 求10次结果 \tfmt.Println(randFewInt(10, 5, 6)) } } /* 实现函数 * f(sum, n) return []int * sum 表示总和，n表示个数， max表示生成的随机数小于max * []int 表示n个随机数 */ func randFewInt(sum, n, max int) []int { var vals, numList []int valSet := map[int]struct{}{} // 最大值不能大于总和 \tmin := float64(sum) / float64(n) if float64(max) \u0026lt;= min { max = int(math.Floor(min)) + 1 } if max \u0026lt; sum { max2 := max // 将0-sum分割成长度小于max的x段 \tfor i := 0; i \u0026lt; n-1; i++ { val := max2 - 1 valSet[val] = struct{}{} max2 = val + max if max2 \u0026gt; sum { break } } } // 把筛选出还没被选中的数 \tvar ls []int for i := 1; i \u0026lt; sum; i++ { if _, ok := valSet[i]; !ok { ls = append(ls, i) } else { vals = append(vals, i) } } // 分割成n段需要n-1个随机数，从筛选出的数中随机出剩余个数的数 \t//log.Printf(\u0026#34; ====== ls=%v vals=%v\u0026#34;, ls, vals) \tremainCnt := n - 1 - len(vals) vals = append(vals, RandIntSample(ls, remainCnt, false)...) // 在n-1个数中加上首端和末端， 即0和sum \tvals = append(vals, 0, sum) // 对n+1个数进行排序 \tsort.Ints(vals) //log.Printf(\u0026#34; ====== raminCnt=%d vals=%v\u0026#34;, remainCnt, vals)  // 求出每一段的长度， 即n个随机数 \tfor i := 1; i \u0026lt; len(vals); i++ { a := vals[i] - vals[i-1] numList = append(numList, a) } return numList } /* 从数组list中随机取n个数 * canRepeat 表示是否可重复 * 取出的数如果不可重复就不会出现0的随机数 */ func RandIntSample(list []int, n int, canRepeat bool) []int { var args []interface{} for _, e := range list { args = append(args, e) } sampleList := RandSample(args, n, canRepeat) var ret []int for _, e := range sampleList { ret = append(ret, e.(int)) } return ret } // 接口化实现， 即可用于任何类型的数组，不只是int型 /* 从数组list中随机取n个数 * canRepeat 表示是否可重复 * 取出的数如果不可重复就不会出现0的随机数 */ func RandSample(list []interface{}, n int, canRepeat bool) []interface{} { if n \u0026lt;= 0 { return []interface{}{} } if !canRepeat \u0026amp;\u0026amp; len(list) \u0026lt;= n { return list } var ret []interface{} var set map[int]struct{} if !canRepeat { set = make(map[int]struct{}) } for len(ret) \u0026lt; n { i := rand.Intn(len(list)) if !canRepeat { if _, ok := set[i]; ok { continue } set[i] = struct{}{} } ret = append(ret, list[i]) } return ret } "},{"id":38,"href":"/note/docs/golang/other-recode/","title":"零碎笔记","section":"Go语言笔记","content":" 本文记录一些golang程序的一些简短的要点\n 求int64的最大值 #  maxInt64 := int64(^uint64(0)\u0026gt;\u0026gt;1) "},{"id":39,"href":"/note/docs/kubernetes/kubernetes-setup/","title":"Kubernetes服务部署步骤","section":"Kubernetes","content":" kubernetes，简称K8s，是用8代替8个字符“ubernete”而成的缩写。 是一个开源的，用于管理云平台中多个主机上的容器化的应用， Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）, Kubernetes提供了应用部署，规划，更新，维护的一种机制。 本文将介绍Kubernetes集群的部署步骤\n 一、环境要求 #   物理机 × 3 (master × 1 + node × 2)【4核8G】 Linux发行版：CentOS7 Linux内核：3.10.0-1160.25.1.el7.x86_64 docker-ce 18.09.9 k8s v1.16.0  二、Kubernetes集群搭建 #  1、修改机器参数 #  # 分别修改三台机器的主机名 hostnamectl set-hostname master hostnamectl set-hostname node1 hostnamectl set-hostname node2 2、安装docker（所有机器） #  # 安装docker所需的工具 yum install -y yum-utils device-mapper-persistent-data lvm2 # 配置阿里云的docker源 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 指定安装这个版本的docker-ce yum install -y docker-ce-18.09.9-3.el7 # 启动docker systemctl enable docker \u0026amp;\u0026amp; systemctl start docker 3、设置k8s环境变量（所有机器） #  # 关闭防火墙 systemctl disable firewalld systemctl stop firewalld # 关闭selinux # 临时禁用selinux setenforce 0 # 永久关闭 修改/etc/sysconfig/selinux文件设置 sed -i \u0026#39;s/SELINUX=permissive/SELINUX=disabled/\u0026#39; /etc/sysconfig/selinux sed -i \u0026#34;s/SELINUX=enforcing/SELINUX=disabled/g\u0026#34; /etc/selinux/config # 禁用交换分区 swapoff -a # 永久禁用，打开/etc/fstab注释掉swap那一行。 sed -i \u0026#39;s/.*swap.*/#\u0026amp;/\u0026#39; /etc/fstab # 修改内核参数 cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sysctl --system 4、安装配置master节点（只在master操作） #  # 安装kubeadm、kubelet、kubectl # 由于官方k8s源在google，国内无法访问，这里使用阿里云yum源 # 执行配置k8s阿里云源 cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/ enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF # 安装kubeadm、kubectl、kubelet yum install -y kubectl-1.16.0-0 kubeadm-1.16.0-0 kubelet-1.16.0-0 # 启动kubelet服务 systemctl enable kubelet \u0026amp;\u0026amp; systemctl start kubelet # 初始化k8s 以下这个命令开始安装k8s需要用到的docker镜像 # 因为无法访问到国外网站，所以这条命令使用的是国内的阿里云的源(registry.aliyuncs.com/google_containers)。 # 另一个非常重要的是：这里的--apiserver-advertise-address使用的是master和node间能互相ping通的master ip，测试环境中是192.168.99.104，请修改成自己的ip再执行。 # 这条命令执行时会卡在[preflight] You can also perform this action in beforehand using \u0026#39;\u0026#39;kubeadm config images pull，大概需要2分钟，请耐心等待。 kubeadm init --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.16.0 --apiserver-advertise-address 192.168.60.143 --pod-network-cidr=10.244.0.0/16 --token-ttl 0 # 上面安装完成后，k8s会提示你输入如下命令，执行 mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config # 查询node 加入 master的命令 kubeadm token create --print-join-command 5、安装node工作节点（所有node节点） #  # 安装kubeadm、kubelet # 执行配置k8s阿里云源 cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/ enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF # 安装kubeadm、kubectl、kubelet yum install -y kubeadm-1.16.0-0 kubelet-1.16.0-0 # 启动kubelet服务 systemctl enable kubelet \u0026amp;\u0026amp; systemctl start kubelet # 加入集群，如果这里不知道加入集群的命令，可以登录master节点，使用kubeadm token create --print-join-command 来获取 kubeadm join 192.168.99.104:6443 --token ncfrid.7ap0xiseuf97gikl \\ --discovery-token-ca-cert-hash sha256:47783e9851a1a517647f1986225f104e81dbfd8fb256ae55ef6d68ce9334c6a2 6、安装flannel网络组件（只在master操作） #  kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml # 安装完成之后，可通过 kubectl get nodes 命令查看所有节点是否都为Ready状态，全为Ready说明节点间网络已打通了 7、部署Ingress控制器：traefik v2.3 #    traefik介绍\n Traefik 是一个边缘路由器。由于 Traefik 2.X 版本和之前的 1.X 版本不兼容，我们这里选择功能更加强大的 2.X 版本来和大家进行讲解，我们这里使用的镜像是 traefik:2.3。\n在 Traefik 中的配置可以使用两种不同的方式：\n 动态配置：完全动态的路由配置 静态配置：启动配置  静态配置中的元素（这些元素不会经常更改）连接到 providers 并定义 Treafik 将要监听的 entrypoints。\n 在 Traefik 中有三种方式定义静态配置：在配置文件中、在命令行参数中、通过环境变量传递\n 动态配置包含定义系统如何处理请求的所有配置内容，这些配置是可以改变的，而且是无缝热更新的，没有任何请求中断或连接损耗。\nps: 具体可参考文章： 一文搞懂 Traefik2.1 的使用\n   创建域名证书验证\n 从域名服务商那里可以免费申请域名的tls证书，将其重名为tls.crt和tls.key\n然后使用下面命令生成k8s的域名验证信息， domain-tls为名称，后续会用到，可自行定义\n kubectl create secret tls domain-tls --cert=tls.crt --key=tls.key   获取traefik安装文件\ngit clone https://github.com/jageros/treafik-profile.git   修改文件配置\n 拉取到的仓库有四个yaml文件，其中crd.yaml和rbac.yaml两个文件是不需要修改的，其他两个需要做如下修改\n # deployment.yaml #通过kubectl get nodes命令可以查看节点名称 ... nodeSelector: kubernetes.io/hostname: master  # master必须为master节点的名称，根据自己的修改 ... # dashboard.yaml ... routes: - match: Host(`www.domain.com`)  # 域名要改成自己的域名 ... ... ... tls: secretName: domain-tls # 这个即上面生成域名验证信息的名称，需要改成相应的   安装traefik\n# 通过shell脚本直接安装即可 sh apply.sh   检查traefik是否正常运行\n[root@master ~]# kubectl get pods -n kube-system NAME READY STATUS RESTARTS AGE coredns-58cc8c89f4-4qq8h 1/1 Running 14 27d coredns-58cc8c89f4-vqj7f 1/1 Running 14 27d etcd-master 1/1 Running 16 27d kube-apiserver-master 1/1 Running 16 27d kube-controller-manager-master 1/1 Running 18 27d kube-flannel-ds-26rkn 1/1 Running 18 27d kube-flannel-ds-68fv6 1/1 Running 16 27d kube-flannel-ds-n827d 1/1 Running 14 27d kube-flannel-ds-w4w2c 1/1 Running 16 27d kube-proxy-6rnfh 1/1 Running 14 27d kube-proxy-m4ck5 1/1 Running 14 27d kube-proxy-rzb4h 1/1 Running 16 27d kube-proxy-sc5px 1/1 Running 14 27d kube-scheduler-master 1/1 Running 18 27d traefik-78878774df-vzsc4 1/1 Running 4 11d   检查是否可外网访问\n 在域名解析中添加解析到master的IP，然后访问域名，看是否可以访问到dashboard UI（如图所示）\n    三、部署应用 #  1、编译应用上传到docker仓库 #    修改编译脚本配置信息\n 编译脚本为项目中的build_all.sh，build_item.sh和Dockerfile文件\n修改build_all.sh中的版本号和build_item.sh中的仓库地址\n然后执行sh build_all.sh编译即可\n   修改服务应用的yaml文件\n 应用的yaml文件在项目目录下的k8s文件夹下面，需要把镜像的版本号修改成对应build_all.sh文件中的\n域名和验证的tls名称也要改成对应的\n   2、部署应用 #    先准备好Etcd、Redis、MongoDB和MySQL，并把配置写入到etcd中\n  把应用的yaml文件打包上传到master机器上\n  通过执行apply.sh脚本即可让应用跑起来\n  3、 测试服务是否正常 #   通过dashborad ui查看路由是否正常 通过kubectl get pods -n yinyin命令查看pod状态是否正常  4、更新应用 #   版本号递增，然后修改yaml中的版本号 应用：kubectl apply -f xxx.yaml  5、停止应用 #  sh delete.sh 参考 #    kube-flannel.yml  traefik教程 "}]